#!/usr/bin/env python3
"""
Aero Strike (AI-Powered Wifi Penetration Testing Tool)
Advanced Wireless Network Penetration Testing Suite with Real-time Scanning and Analysis
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from tkinter.scrolledtext import ScrolledText
import threading
import webbrowser
import os
import shutil
import time
import subprocess
import json
import types
import re
from tkinter import font as tkfont
from enum import Enum, auto
import sys
from datetime import datetime

# Import the core module correctly
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from src.pentest_core import PentestController, SecurityUtils, NetworkTarget, AttackType
from src.dialog_utils import configure_dialog_for_display, create_maximize_button
from src.utils import get_icon_as_image, save_config, load_config
from src.post_exploitation_gui import PostExploitationGUI
from src.traffic_analysis_gui import TrafficAnalysisGUI
# Removed firmware analysis import
from src.ai_assistant_gui import AIAssistantGUI
# Removed offline AI assistant - only using online version
from src.advanced_reports import ReportGenerator
from assets.theme import ThemeManager

class WiFiPentestGUI:
    def __init__(self, root):
        self.root = root
        # Initialize all state flags
        self.running = True
        self.scanning = False
        self.attacking = False
        
        self.root.title("Aero Strike (AI-Powered Wifi Penetration Testing Tool)")
        self.root.geometry("1280x800")
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)
        
        # Initialize variables
        self.dark_mode = True
        self.font_size = "medium"  # Default font size
        self.stop_event = threading.Event()
        
        # Initialize theme manager with font size support
        self.theme_manager = ThemeManager(self.root, dark_mode=self.dark_mode, font_size=self.font_size)
        self.current_target = None
        self.scan_results = []
        self.report_generator = None
        
        # Setup UI components
        self.setup_main_frame()
        self.setup_style()
        self.setup_controls()
        self.setup_network_list()
        self.setup_console()
        self.setup_progress()
        self.setup_status_bar()
        
        # Setup log tags after console is created
        self.setup_log_tags()
        
        # Detect development environment
        self.is_dev_mode = False
        if 'REPL_ID' in os.environ or 'REPLIT' in os.environ:
            self.is_dev_mode = True
            self.log("DEVELOPMENT MODE ACTIVE: Simulating wireless hardware", warning=True)
        
        # Initialize controller after UI is set up
        self.controller = PentestController(callback=self.log)
        
        # Initialize storage for cracked networks
        self.cracked_networks = []
        
        # Check prerequisites to warn about missing dependencies
        self.check_prerequisites()
        
        # Load config and apply theme
        self.load_config()
        self.apply_theme()
        
        # Check if we have interfaces available
        self.refresh_interfaces()

    def on_close(self):
        """Handle window close event safely"""
        # Stop any ongoing operations
        if self.scanning:
            self.stop_scan()

        # Confirm exit if any operations are running
        if self.controller.running:
            if not messagebox.askokcancel("Quit", "Scan/Attack in progress. Force quit?"):
                return

        # Clean up resources
        self.running = False
        if hasattr(self.controller, 'scanner'):
            scanner = self.controller.scanner
            if scanner is not None and hasattr(scanner, 'stop_event'):
                scanner.stop_event.set()

        # Log before destroying window to avoid errors
        try:
            self.log("Application closed", success=True)
        except:
            pass
            
        # Close window
        self.root.destroy()

    def toggle_theme(self):
        """Toggle between dark and light mode"""
        self.dark_mode = not self.dark_mode
        self.theme_btn.config(text="üåô" if self.dark_mode else "‚òÄÔ∏è")
        
        # Update theme manager and apply
        self.theme_manager.dark_mode = self.dark_mode
        self.apply_theme()
        
        # Force update of all widgets
        self.root.update_idletasks()
        
    def setup_main_frame(self):
        """Setup main application frame"""
        self.main_frame = ttk.Frame(self.root)
        self.main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create a PanedWindow for resizable sections
        self.paned_window = ttk.PanedWindow(self.main_frame, orient=tk.HORIZONTAL)
        self.paned_window.pack(fill=tk.BOTH, expand=True, padx=10, pady=(10, 0))
        
        # Left panel for network list
        self.left_panel = ttk.Frame(self.paned_window)
        self.paned_window.add(self.left_panel, weight=1)
        
        # Right panel for console and details
        self.right_panel = ttk.Frame(self.paned_window)
        self.paned_window.add(self.right_panel, weight=2)
        
    def setup_style(self):
        """Setup custom ttk styles"""
        self.style = ttk.Style()
        self.style.configure("TButton", padding=6, relief="flat", font=("Helvetica", 10))
        self.style.configure("TFrame", background="#2d2d2d")
        self.style.configure("TLabel", background="#2d2d2d", foreground="#ffffff")
        self.style.configure("TNotebook", background="#2d2d2d", foreground="#ffffff")
        self.style.configure("TNotebook.Tab", background="#2d2d2d", foreground="#ffffff")
        
        # Custom header style
        self.style.configure("Header.TLabel", font=("Helvetica", 16, "bold"))
        
        # Custom button styles
        self.style.configure("Action.TButton", background="#0078d7", foreground="#ffffff")
        self.style.configure("Warning.TButton", background="#d73a00", foreground="#ffffff")
        
    def apply_theme(self):
        """Apply dark or light theme to all components using ThemeManager"""
        # Update the theme manager's dark mode setting
        self.theme_manager.dark_mode = self.dark_mode
        
        # Apply theme through theme manager
        self.theme_manager.apply_theme()
        
        # Get theme colors for manual widget styling
        colors = self.theme_manager.get_theme_colors()
        
        # Update widgets that need manual styling
        if hasattr(self, 'console'):
            self.console.config(bg=colors["secondary_bg"], fg=colors["fg"])
            
        if hasattr(self, 'status_bar'):
            self.status_bar.config(bg=colors["bg"], fg=colors["fg"])
            
        if hasattr(self, 'progress_frame'):
            self.progress_frame.config(bg=colors["bg"])
            
        if hasattr(self, 'network_tree'):
            self.style.configure("Treeview", 
                                background=colors["secondary_bg"], 
                                foreground=colors["fg"],
                                fieldbackground=colors["secondary_bg"])
            self.style.map("Treeview", 
                          background=[('selected', colors["accent"])],
                          foreground=[('selected', '#ffffff')])
        
        # Update button styles to colorful buttons
        if hasattr(self, 'scan_btn'):
            self.scan_btn.configure(style="Scan.TButton")
            
        if hasattr(self, 'stop_btn'):
            self.stop_btn.configure(style="Error.TButton")
            
        if hasattr(self, 'view_traffic_btn'):
            self.view_traffic_btn.configure(style="Analyze.TButton")
            
        if hasattr(self, 'ai_btn'):
            self.ai_btn.configure(style="AI.TButton")
            
        if hasattr(self, 'post_exploit_btn'):
            self.post_exploit_btn.configure(style="PostExploit.TButton")
            
        if hasattr(self, 'advanced_reports_btn'):
            self.advanced_reports_btn.configure(style="Report.TButton")
            
        if hasattr(self, 'advanced_btn'):
            self.advanced_btn.configure(style="Settings.TButton")
            
        if hasattr(self, 'help_btn'):
            self.help_btn.configure(style="Help.TButton")
        
        # Save theme preference to config
        self.save_config()
        
    def setup_controls(self):
        """Setup control buttons and interface selector"""
        # Top control frame
        self.control_frame = ttk.Frame(self.main_frame)
        self.control_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Interface selection
        interface_label = ttk.Label(self.control_frame, text="Interface:")
        interface_label.pack(side=tk.LEFT, padx=(0, 5))
        
        self.interface_var = tk.StringVar()
        self.interface_dropdown = ttk.Combobox(self.control_frame, 
                                              textvariable=self.interface_var,
                                              width=10,
                                              state="readonly")
        self.interface_dropdown.pack(side=tk.LEFT, padx=(0, 10))
        
        # Refresh interfaces button
        refresh_btn = ttk.Button(self.control_frame, 
                                text="‚ü≥", 
                                width=3,
                                command=self.refresh_interfaces,
                                style="Scan.TButton")
        refresh_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        # Mode toggle (Monitor/Managed)
        self.mode_btn = ttk.Button(self.control_frame, 
                                  text="Set Monitor Mode", 
                                  command=self.toggle_interface_mode,
                                  style="Settings.TButton")
        self.mode_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        # Scan time
        scan_time_label = ttk.Label(self.control_frame, text="Scan Time (s):")
        scan_time_label.pack(side=tk.LEFT, padx=(10, 5))
        
        self.scan_time_var = tk.IntVar(value=60)
        scan_time_spin = ttk.Spinbox(self.control_frame, 
                                     from_=5, 
                                     to=300, 
                                     textvariable=self.scan_time_var,
                                     width=5)
        scan_time_spin.pack(side=tk.LEFT, padx=(0, 10))
        
        # Scan button with colorful style
        self.scan_btn = ttk.Button(self.control_frame, 
                                  text="Start Scan", 
                                  command=self.start_scan,
                                  style="Scan.TButton")
        self.scan_btn.pack(side=tk.LEFT, padx=(0, 10))
        
        # Theme button
        self.theme_btn = ttk.Button(self.control_frame, 
                                   text="üåô", 
                                   width=3,
                                   command=self.toggle_theme,
                                   style="AI.TButton")
        self.theme_btn.pack(side=tk.RIGHT, padx=5)
        
        # Help button
        self.help_btn = ttk.Button(self.control_frame, 
                             text="?", 
                             width=3,
                             command=self.show_help_dialog,
                             style="Help.TButton")
        self.help_btn.pack(side=tk.RIGHT, padx=5)
        
        # Advanced button
        self.advanced_btn = ttk.Button(self.control_frame, 
                                 text="Advanced", 
                                 command=self.show_advanced_dialog,
                                 style="Settings.TButton")
        self.advanced_btn.pack(side=tk.RIGHT, padx=5)
        
        # Advanced Reports button
        self.advanced_reports_btn = ttk.Button(self.control_frame, 
                                text="Advanced Reports", 
                                command=self.show_advanced_reports,
                                style="Report.TButton")
        self.advanced_reports_btn.pack(side=tk.RIGHT, padx=5)
        
        # Network Traffic Monitor button
        self.view_traffic_btn = ttk.Button(self.control_frame, 
                                        text="Network Monitor", 
                                        command=self.show_traffic_analysis,
                                        style="Analyze.TButton")
        self.view_traffic_btn.pack(side=tk.RIGHT, padx=5)
        
        # Unified AI Assistant button that chooses the best mode automatically
        self.ai_btn = ttk.Button(self.control_frame, 
                           text="AI Security Helper", 
                           command=self.show_smart_ai_assistant,
                           style="AI.TButton")
        self.ai_btn.pack(side=tk.RIGHT, padx=5)



        # Post-Exploitation button
        self.post_exploit_btn = ttk.Button(self.control_frame, 
                                     text="Post-Exploitation", 
                                     command=self.show_post_exploitation,
                                     style="PostExploit.TButton")
        self.post_exploit_btn.pack(side=tk.RIGHT, padx=5)
        
        # Simple Report button - put back outside as requested
        self.simple_report_btn = ttk.Button(self.control_frame, 
                                      text="Simple Report", 
                                      command=lambda: self.generate_report(),
                                      style="Report.TButton")
        self.simple_report_btn.pack(side=tk.RIGHT, padx=5)
        
        # Interface dropdown event binding
        self.interface_dropdown.bind("<<ComboboxSelected>>", self.on_interface_selected)
        
    def setup_network_list(self):
        """Setup network list treeview"""
        # Network list header
        self.network_header = ttk.Frame(self.left_panel)
        self.network_header.pack(fill=tk.X, pady=(0, 5))
        
        networks_label = ttk.Label(self.network_header, 
                                  text="Discovered Networks", 
                                  style="Header.TLabel")
        networks_label.pack(side=tk.LEFT, pady=5)
        
        # Attack all button
        self.attack_all_btn = ttk.Button(self.network_header, 
                                        text="Test All", 
                                        command=self.show_attack_all_dialog,
                                        state=tk.DISABLED)
        self.attack_all_btn.pack(side=tk.RIGHT, padx=5)
        
        # Network treeview with scrollbar
        columns = ("ssid", "security", "strength", "clients", "channel")
        self.network_tree = ttk.Treeview(self.left_panel, columns=columns, show="headings", height=25)
        
        # Configure columns
        self.network_tree.heading("ssid", text="Network Name")
        self.network_tree.heading("security", text="Security")
        self.network_tree.heading("strength", text="Signal")
        self.network_tree.heading("clients", text="Clients")
        self.network_tree.heading("channel", text="Ch")
        
        self.network_tree.column("ssid", width=150)
        self.network_tree.column("security", width=80)
        self.network_tree.column("strength", width=60)
        self.network_tree.column("clients", width=50)
        self.network_tree.column("channel", width=40)
        
        # Add scrollbar
        tree_scroll = ttk.Scrollbar(self.left_panel, orient="vertical", command=self.network_tree.yview)
        self.network_tree.configure(yscrollcommand=tree_scroll.set)
        
        # Pack list and scrollbar
        self.network_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        tree_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Bind selection event
        self.network_tree.bind("<<TreeviewSelect>>", self.on_network_selected)
        self.network_tree.bind("<Double-1>", self.on_network_double_click)
        
    def setup_console(self):
        """Setup console output and network details view"""
        # Create a notebook for console and details
        self.notebook = ttk.Notebook(self.right_panel)
        self.notebook.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Console tab
        self.console_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.console_frame, text="Console")
        
        self.console = ScrolledText(self.console_frame, wrap=tk.WORD, height=25)
        self.console.pack(fill=tk.BOTH, expand=True)
        self.console.config(state=tk.DISABLED)
        
        # Details tab
        self.details_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.details_frame, text="Network Details")
        
        # Create details view
        self.setup_details_view()
        
        # Attack modules tab
        self.attack_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.attack_frame, text="Attack Modules")
        
        self.setup_attack_modules()
        
    def setup_details_view(self):
        """Setup network details display"""
        # Container for details
        self.details_container = ttk.Frame(self.details_frame)
        self.details_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Network details header
        self.details_header = ttk.Frame(self.details_container)
        self.details_header.pack(fill=tk.X, pady=(0, 10))
        
        self.details_title = ttk.Label(self.details_header, 
                                      text="Select a Network", 
                                      style="Header.TLabel")
        self.details_title.pack(side=tk.LEFT)
        
        # Network info section
        self.details_info = ttk.Frame(self.details_container)
        self.details_info.pack(fill=tk.X, pady=5)
        
        # Create grid for details
        labels = ["SSID:", "BSSID:", "Channel:", "Security:", "Signal:", "Clients:", 
                 "Vendor:", "WPS Status:", "Auth Type:", "Encryption:", "Password:"]
        
        # Storage for detail value labels
        self.detail_values = {}
        
        # Create info grid
        for i, label_text in enumerate(labels):
            row = i // 2
            col = (i % 2) * 2
            
            # Label
            label = ttk.Label(self.details_info, text=label_text, font=("Helvetica", 10, "bold"))
            label.grid(row=row, column=col, sticky=tk.W, padx=(10 if col==0 else 40), pady=5)
            
            # Value
            value = ttk.Label(self.details_info, text="-")
            value.grid(row=row, column=col+1, sticky=tk.W, pady=5)
            
            # Store reference to value label
            self.detail_values[label_text.replace(":", "").lower()] = value
        
        # Risk assessment section
        self.risk_frame = ttk.LabelFrame(self.details_container, text="Risk Assessment")
        self.risk_frame.pack(fill=tk.X, pady=10, padx=5)
        
        # Risk score progress bar
        self.risk_score_frame = ttk.Frame(self.risk_frame)
        self.risk_score_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.risk_score_label = ttk.Label(self.risk_score_frame, text="Risk Score: 0%")
        self.risk_score_label.pack(side=tk.TOP, anchor=tk.W)
        
        self.risk_score_bar = ttk.Progressbar(self.risk_score_frame, orient=tk.HORIZONTAL, length=100, mode='determinate')
        self.risk_score_bar.pack(fill=tk.X, pady=(5, 10))
        
        # Vulnerabilities list
        self.vuln_frame = ttk.Frame(self.risk_frame)
        self.vuln_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        vuln_label = ttk.Label(self.vuln_frame, text="Detected Vulnerabilities:", font=("Helvetica", 10, "bold"))
        vuln_label.pack(anchor=tk.W, pady=(0, 5))
        
        self.vuln_list = tk.Listbox(self.vuln_frame, height=5)
        self.vuln_list.pack(fill=tk.BOTH, expand=True)
        
    def setup_attack_modules(self):
        """Setup attack modules interface"""
        # Attack modules container
        self.attack_container = ttk.Frame(self.attack_frame)
        self.attack_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Attack modules header
        self.attack_header = ttk.Frame(self.attack_container)
        self.attack_header.pack(fill=tk.X, pady=(0, 10))
        
        self.attack_title = ttk.Label(self.attack_header, 
                                    text="Attack Modules", 
                                    style="Header.TLabel")
        self.attack_title.pack(side=tk.LEFT)
        
        # Network selection info
        self.attack_target = ttk.Label(self.attack_header, 
                                     text="Target: None Selected", 
                                     font=("Helvetica", 10, "italic"))
        self.attack_target.pack(side=tk.RIGHT)
        
        # Attack modules in a scrollable frame
        self.attack_scroll = tk.Canvas(self.attack_container)
        self.attack_scrollbar = ttk.Scrollbar(self.attack_container, orient=tk.VERTICAL, command=self.attack_scroll.yview)
        self.attack_frame_inner = ttk.Frame(self.attack_scroll)
        
        self.attack_scroll.configure(yscrollcommand=self.attack_scrollbar.set)
        self.attack_scroll.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.attack_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Create a window inside the canvas to hold the inner frame
        self.attack_scroll.create_window((0, 0), window=self.attack_frame_inner, anchor=tk.NW)
        self.attack_frame_inner.bind("<Configure>", lambda e: self.attack_scroll.configure(scrollregion=self.attack_scroll.bbox("all")))
        
        # Create individual attack module panels
        self.create_attack_panels()
        
    def create_attack_panels(self):
        """Create panels for each attack type"""
        # WPA handshake attack
        wpa_frame = ttk.LabelFrame(self.attack_frame_inner, text="WPA/WPA2 Handshake Capture")
        wpa_frame.pack(fill=tk.X, expand=True, padx=5, pady=5)
        
        wpa_desc = ttk.Label(wpa_frame, 
                           text="Captures 4-way WPA handshake for later offline cracking", 
                           wraplength=400)
        wpa_desc.pack(anchor=tk.W, padx=10, pady=5)
        
        wpa_btn = ttk.Button(wpa_frame, 
                            text="Capture WPA Handshake", 
                            command=lambda: self.run_attack(AttackType.WPA),
                            state=tk.DISABLED)
        wpa_btn.pack(fill=tk.X, padx=10, pady=10)
        
        # Store reference to button
        self.attack_buttons = {
            AttackType.WPA: wpa_btn
        }
        
        # WPS PIN attack
        wps_frame = ttk.LabelFrame(self.attack_frame_inner, text="WPS PIN Attack")
        wps_frame.pack(fill=tk.X, expand=True, padx=5, pady=5)
        
        wps_desc = ttk.Label(wps_frame, 
                           text="Attempts to exploit WPS PIN vulnerabilities", 
                           wraplength=400)
        wps_desc.pack(anchor=tk.W, padx=10, pady=5)
        
        wps_btn = ttk.Button(wps_frame, 
                            text="Run WPS PIN Attack", 
                            command=lambda: self.run_attack(AttackType.WPS),
                            state=tk.DISABLED)
        wps_btn.pack(fill=tk.X, padx=10, pady=10)
        
        # Store reference to button
        self.attack_buttons[AttackType.WPS] = wps_btn
        
        # WEP attack
        wep_frame = ttk.LabelFrame(self.attack_frame_inner, text="WEP Attack")
        wep_frame.pack(fill=tk.X, expand=True, padx=5, pady=5)
        
        wep_desc = ttk.Label(wep_frame, 
                           text="Collects IVs to crack WEP encryption", 
                           wraplength=400)
        wep_desc.pack(anchor=tk.W, padx=10, pady=5)
        
        wep_btn = ttk.Button(wep_frame, 
                            text="Run WEP Attack", 
                            command=lambda: self.run_attack(AttackType.WEP),
                            state=tk.DISABLED)
        wep_btn.pack(fill=tk.X, padx=10, pady=10)
        
        # Store reference to button
        self.attack_buttons[AttackType.WEP] = wep_btn
        
        # PMKID attack module has been removed
        
        # Default credentials check
        creds_frame = ttk.LabelFrame(self.attack_frame_inner, text="Default Credentials Check")
        creds_frame.pack(fill=tk.X, expand=True, padx=5, pady=5)
        
        creds_desc = ttk.Label(creds_frame, 
                             text="Tests for default and common credentials for the device", 
                             wraplength=400)
        creds_desc.pack(anchor=tk.W, padx=10, pady=5)
        
        creds_btn = ttk.Button(creds_frame, 
                              text="Check Default Credentials", 
                              command=lambda: self.run_attack(AttackType.DEFAULT_CREDS),
                              state=tk.DISABLED)
        creds_btn.pack(fill=tk.X, padx=10, pady=10)
        
        # Store reference to button
        self.attack_buttons[AttackType.DEFAULT_CREDS] = creds_btn
        
        # Evil Twin attack module has been removed
    
    def setup_progress(self):
        """Setup progress bar and action buttons"""
        # Progress frame
        self.progress_frame = tk.Frame(self.main_frame)
        self.progress_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Progress bar
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(self.progress_frame, 
                                           variable=self.progress_var,
                                           maximum=100)
        self.progress_bar.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        # Stop button
        self.stop_btn = ttk.Button(self.progress_frame, 
                                  text="Stop", 
                                  command=self.stop_current_operation,
                                  state=tk.DISABLED,
                                  style="Error.TButton")
        self.stop_btn.pack(side=tk.RIGHT, padx=(10, 0))
        
    def setup_status_bar(self):
        """Setup status bar at bottom"""
        self.status_bar = tk.Label(self.root, 
                                  text="Ready", 
                                  bd=1, 
                                  relief=tk.SUNKEN, 
                                  anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
    def setup_log_tags(self):
        """Setup text tags for console coloring"""
        # Configure console for colorized output
        self.console.tag_configure("error", foreground="red")
        self.console.tag_configure("warning", foreground="orange")
        self.console.tag_configure("success", foreground="green")
        self.console.tag_configure("info", foreground="white")
        self.console.tag_configure("phase", foreground="cyan")
        self.console.tag_configure("hardware", foreground="yellow")
        self.console.tag_configure("scan", foreground="magenta")
        self.console.tag_configure("attack", foreground="red")
        
    def log(self, message, error=False, warning=False, success=False, phase=None):
        """Add log message to console"""
        # Enable editing
        self.console.config(state=tk.NORMAL)
        
        # Add timestamp
        timestamp = datetime.now().strftime("%H:%M:%S")
        prefix = f"[{timestamp}] "
        
        # Add phase indicator if specified
        if phase:
            prefix += f"[{phase}] "
            
        # Insert text with appropriate tag
        self.console.insert(tk.END, prefix, "info")
        
        # Apply the appropriate tag
        tag = None
        if error:
            tag = "error"
        elif warning:
            tag = "warning"
        elif success:
            tag = "success"
        elif phase:
            tag = "phase"
        else:
            tag = "info"
            
        self.console.insert(tk.END, message + "\n", tag)
        
        # Autoscroll to bottom
        self.console.see(tk.END)
        
        # Disable editing
        self.console.config(state=tk.DISABLED)
        
        # Update status bar if message is important
        if error or warning or success:
            self.status_bar.config(text=message)
            
    def refresh_interfaces(self):
        """Refresh wireless interface list"""
        if self.is_dev_mode:
            # In development mode, show simulated interfaces
            interfaces = ["wlan0", "wlan1"]
            self.log("DEVELOPMENT MODE: Using simulated interfaces", warning=True)
        else:
            # Get actual interfaces
            interfaces = SecurityUtils.list_wireless_interfaces()
            
        # Update dropdown
        self.interface_dropdown['values'] = interfaces
        
        if interfaces:
            # Select first interface
            self.interface_dropdown.current(0)
            self.on_interface_selected(None)
            self.log(f"Found {len(interfaces)} wireless interfaces", success=True)
        else:
            self.log("No wireless interfaces found", error=True)
            
    def on_interface_selected(self, event):
        """Handle interface selection event"""
        interface = self.interface_var.get()
        if interface:
            # Set selected interface
            success, msg = self.controller.set_interface(interface)
            
            if success:
                self.log(f"Using interface: {interface}", success=True)
                
                # Check interface mode
                self.update_interface_mode()
            else:
                self.log(f"Error: {msg}", error=True)
                
    def update_interface_mode(self):
        """Update interface mode display and button text"""
        interface = self.interface_var.get()
        if not interface:
            return
            
        if self.is_dev_mode:
            # In development mode, assume managed mode initially
            current_mode = "managed"
        else:
            # Get actual mode
            current_mode = SecurityUtils.get_interface_mode(interface)
            
        # Update button text based on current mode
        if current_mode == "monitor":
            self.mode_btn.config(text="Set Managed Mode")
            self.log(f"Interface {interface} is in monitor mode", success=True)
        else:
            self.mode_btn.config(text="Set Monitor Mode")
            
    def toggle_interface_mode(self):
        """Toggle interface between monitor and managed mode"""
        interface = self.interface_var.get()
        if not interface:
            self.log("No interface selected", error=True)
            return
            
        # Get current mode
        if self.is_dev_mode:
            # In development mode, just toggle mode display
            if self.mode_btn["text"] == "Set Monitor Mode":
                new_mode = "monitor"
                self.mode_btn.config(text="Set Managed Mode")
                self.log("DEVELOPMENT MODE: Interface set to monitor mode", warning=True)
            else:
                new_mode = "managed"
                self.mode_btn.config(text="Set Monitor Mode")
                self.log("DEVELOPMENT MODE: Interface set to managed mode", warning=True)
        else:
            # Get actual current mode
            current_mode = SecurityUtils.get_interface_mode(interface)
            
            # Set to opposite mode
            new_mode = "managed" if current_mode == "monitor" else "monitor"
            
            # Toggle mode
            self.log(f"Setting {interface} to {new_mode} mode...", phase="HARDWARE")
            success, msg = SecurityUtils.set_interface_mode(interface, new_mode, self.log)
            
            if success:
                self.update_interface_mode()
            else:
                self.log(f"Failed to set {new_mode} mode: {msg}", error=True)
                
    def start_scan(self):
        """Start network scanning"""
        if self.scanning:
            # If already scanning, stop it
            self.stop_scan()
            return
            
        # Check if we have interface
        interface = self.interface_var.get()
        if not interface:
            self.log("No interface selected", error=True)
            return
            
        # Enable stop button
        self.stop_btn.config(state=tk.NORMAL)
        
        # Change scan button text
        self.scan_btn.config(text="Stop Scan")
        
        # Set scanning flag
        self.scanning = True
        
        # Get scan time
        scan_time = self.scan_time_var.get()
        
        # Start scan in separate thread
        self.scan_thread = threading.Thread(target=self.run_scan, args=(scan_time,))
        self.scan_thread.daemon = True
        self.scan_thread.start()
        
    def run_scan(self, scan_time):
        """Run network scan in background thread"""
        # Mark in-progress
        self.update_progress(0)
        
        try:
            # Start the scan
            self.log(f"Starting network scan ({scan_time} seconds)...", phase="SCAN")
            
            # Clear previous scan results
            self.network_tree.delete(*self.network_tree.get_children())
            
            # Track scan start time
            start_time = time.time()
            
            # Run the scan
            networks = self.controller.scan_networks(scan_time)
            
            # Sort networks by signal strength
            self.scan_results = sorted(list(networks.values()), 
                                      key=lambda x: getattr(x, 'signal_strength', 0), 
                                      reverse=True)
            
            # Add to treeview
            for network in self.scan_results:
                self.network_tree.insert("", tk.END, 
                                        values=(network.ssid, 
                                               network.security_type, 
                                               f"{network.signal_strength}%", 
                                               network.client_count,
                                               network.channel))
            
            # Log completion
            scan_duration = time.time() - start_time
            self.log(f"Scan complete. Found {len(networks)} networks in {scan_duration:.1f} seconds", 
                    success=True, phase="SCAN")
                    
            # Enable attack all button if we found networks
            if self.scan_results:
                self.attack_all_btn.config(state=tk.NORMAL)
            else:
                self.attack_all_btn.config(state=tk.DISABLED)
                
        except Exception as e:
            self.log(f"Scan error: {str(e)}", error=True)
            
        finally:
            # Reset UI state
            self.scanning = False
            self.scan_btn.config(text="Start Scan")
            self.stop_btn.config(state=tk.DISABLED)
            self.update_progress(100)
            
    def stop_scan(self):
        """Stop the current scan"""
        if not self.scanning:
            return
            
        # Stop controller scan
        self.controller.stop_scan()
        
        # Update UI
        self.log("Stopping scan...", phase="SCAN")
        
    def update_progress(self, value):
        """Update progress bar value"""
        self.progress_var.set(value)
        self.root.update_idletasks()
        
    def stop_current_operation(self):
        """Stop current operation (scan or attack)"""
        if self.scanning:
            self.stop_scan()
        elif self.attacking:
            self.stop_attack()
            
    def on_network_selected(self, event):
        """Handle network selection in treeview"""
        selected_items = self.network_tree.selection()
        if not selected_items:
            return
            
        # Get network details for selected item
        item_index = self.network_tree.index(selected_items[0])
        if item_index < len(self.scan_results):
            network = self.scan_results[item_index]
            self.current_target = network
            
            # Switch to details tab
            self.notebook.select(1)
            
            # Update details view
            self.update_details_view(network)
            
            # Update attack target
            self.attack_target.config(text=f"Target: {network.ssid}")
            
            # Enable attack buttons based on network type
            self.update_attack_buttons(network)
            
    def on_network_double_click(self, event):
        """Handle double click on network in treeview"""
        self.on_network_selected(event)  # Update selection
        self.notebook.select(2)  # Switch to attack modules tab
        
    def update_details_view(self, network):
        """Update network details display with selected network"""
        # Update title
        self.details_title.config(text=network.ssid)
        
        # Update network details
        self.detail_values["ssid"].config(text=network.ssid)
        self.detail_values["bssid"].config(text=network.bssid)
        self.detail_values["channel"].config(text=network.channel)
        self.detail_values["security"].config(text=network.security_type)
        self.detail_values["signal"].config(text=f"{network.signal_strength}%")
        self.detail_values["clients"].config(text=str(network.client_count))
        self.detail_values["vendor"].config(text=network.vendor)
        self.detail_values["wps status"].config(text=network.wps_status)
        self.detail_values["auth type"].config(text=network.authentication)
        self.detail_values["encryption"].config(text=network.encryption)
        
        # Display password if available (from WPA handshake capture and automatic cracking)
        if hasattr(network, 'credentials') and network.credentials and 'password' in network.credentials:
            self.detail_values["password"].config(text=network.credentials['password'])
        else:
            self.detail_values["password"].config(text="-")
        
        # Update risk score
        self.risk_score_label.config(text=f"Risk Score: {network.risk_score}%")
        self.risk_score_bar["value"] = network.risk_score
        
        # Update vulnerability list
        self.vuln_list.delete(0, tk.END)
        if network.vulnerabilities:
            for vuln in network.vulnerabilities:
                self.vuln_list.insert(tk.END, vuln)
        else:
            self.vuln_list.insert(tk.END, "No vulnerabilities detected")
            
    def update_attack_buttons(self, network):
        """Enable/disable attack buttons based on network type"""
        # Default state is disabled
        for button in self.attack_buttons.values():
            button.config(state=tk.DISABLED)
            
        # Enable appropriate attacks
        security = network.security_type.upper()
        
        # WPA/WPA2 attacks
        if "WPA" in security:
            self.attack_buttons[AttackType.WPA].config(state=tk.NORMAL)
            # PMKID attack module removed
            
            # WPS attacks for WPA networks
            if network.wps_status != "Disabled":
                self.attack_buttons[AttackType.WPS].config(state=tk.NORMAL)
                
        # WEP attacks
        if "WEP" in security:
            self.attack_buttons[AttackType.WEP].config(state=tk.NORMAL)
            
        # Default credentials check (always enabled)
        self.attack_buttons[AttackType.DEFAULT_CREDS].config(state=tk.NORMAL)
        
        # Evil Twin attack module has been removed
            
    def run_attack(self, attack_type):
        """Run specified attack on selected network"""
        if not self.current_target:
            self.log("No network selected", error=True)
            return
            
        if self.attacking:
            self.log("Attack already in progress", warning=True)
            return
            
        # Set attacking flag
        self.attacking = True
        
        # Enable stop button
        self.stop_btn.config(state=tk.NORMAL)
        
        # Disable all attack buttons during attack
        for button in self.attack_buttons.values():
            button.config(state=tk.DISABLED)
            
        # Switch to console tab
        self.notebook.select(0)
        
        # Reset progress
        self.update_progress(0)
        
        # Start attack in separate thread
        self.attack_thread = threading.Thread(target=self.run_attack_thread, 
                                            args=(attack_type, self.current_target))
        self.attack_thread.daemon = True
        self.attack_thread.start()
        
    def run_attack_thread(self, attack_type, network):
        """Run attack in background thread"""
        try:
            # Start the attack
            self.log(f"Starting {attack_type.name} attack on {network.ssid}...", 
                    phase=attack_type.name)
                    
            # Run the attack
            success, msg, result = self.controller.perform_attack(attack_type, network)
            
            # Log completion
            if success:
                self.log(f"{attack_type.name} attack completed successfully: {msg}", 
                        success=True, phase=attack_type.name)
                
                # For WPA attack with automatic cracking, provide additional notification
                if attack_type == AttackType.WPA and "password" in msg.lower():
                    # Password was cracked automatically
                    if "captured and password cracked" in msg:
                        password = msg.split("password cracked:")[-1].strip()
                        self.log(f"PASSWORD FOUND: {password}", success=True, phase="WPA-CRACK")
                        
                        # Show success message with password
                        self.root.after(100, lambda: messagebox.showinfo(
                            "Password Cracked Successfully",
                            f"WPA password was automatically cracked for {network.ssid}\n\n"
                            f"Password: {password}"
                        ))
            else:
                self.log(f"{attack_type.name} attack failed: {msg}", 
                        error=True, phase=attack_type.name)
                        
        except Exception as e:
            self.log(f"Attack error: {str(e)}", error=True)
            
        finally:
            # Reset UI state
            self.attacking = False
            self.stop_btn.config(state=tk.DISABLED)
            self.update_progress(100)
            
            # Re-enable attack buttons
            if self.current_target:
                self.update_attack_buttons(self.current_target)
                
    def stop_attack(self):
        """Stop the current attack"""
        if not self.attacking:
            return
            
        # Stop controller attack
        self.controller.stop_attack()
        
        # Update UI
        self.log("Stopping attack...", warning=True)
        
    def show_smart_ai_assistant(self):
        """Shows the unified AI security helper with both online and offline modes"""
        try:
            # Import the UnifiedAIHelper class
            from src.unified_ai_helper import UnifiedAIHelper
            
            # Create Unified AI Helper
            self.unified_ai_helper = UnifiedAIHelper(
                parent=self.root,
                controller=self,
                on_close_callback=self.on_unified_ai_helper_close
            )
            
            self.log("AI Security Helper opened with dual online/offline modes", success=True)
                
        except Exception as e:
            self.log(f"Error opening AI Security Helper: {str(e)}", error=True)
            messagebox.showerror("Error", f"Failed to open AI Security Helper: {str(e)}")
    
    def show_ai_assistant(self):
        """Legacy method - now redirects to smart AI assistant"""
        self.show_smart_ai_assistant()
    
    def on_ai_assistant_close(self):
        """Callback when AI Assistant is closed"""
        if hasattr(self, 'ai_assistant_gui'):
            # Clean up resources
            if hasattr(self.ai_assistant_gui, 'cleanup'):
                self.ai_assistant_gui.cleanup()
            
            # Remove reference
            self.ai_assistant_gui = None
            
            self.log("AI Security Helper closed")
            
    # Removed offline AI assistant - only using online version now
            
    def on_unified_ai_helper_close(self):
        """Callback when Unified AI Helper is closed"""
        if hasattr(self, 'unified_ai_helper'):
            # Clean up resources
            if hasattr(self.unified_ai_helper, 'cleanup'):
                self.unified_ai_helper.cleanup()
            
            # Remove reference
            self.unified_ai_helper = None
            
            self.log("AI Security Helper closed")
    
    def diagnose_error_with_ai(self, error_traceback):
        """Use AI Assistant to diagnose an error"""
        # Check if AI Assistant is already open
        if not hasattr(self, 'ai_assistant_gui') or self.ai_assistant_gui is None:
            # Open AI Assistant
            self.show_ai_assistant()
            
            # Give it a moment to initialize
            self.root.after(1000, lambda: self._continue_error_diagnosis(error_traceback))
        else:
            # AI Assistant already open, use it directly
            self._continue_error_diagnosis(error_traceback)
    
    def _continue_error_diagnosis(self, error_traceback):
        """Continue error diagnosis after ensuring AI Assistant is open"""
        try:
            if hasattr(self, 'ai_assistant_gui') and self.ai_assistant_gui is not None:
                # Send error to AI Assistant for diagnosis
                self.ai_assistant_gui.diagnose_error(error_traceback)
            else:
                self.log("AI Assistant not available for error diagnosis", error=True)
        except Exception as e:
            self.log(f"Error using AI assistant for diagnosis: {str(e)}", error=True)
            messagebox.showerror("Error", f"Failed to use AI assistant: {str(e)}")

    # Router Firmware Analysis module has been completely removed
    
    def show_traffic_analysis(self):
        """Show simplified network traffic monitor for packet capture and analysis"""
        try:
            # Create traffic analysis dialog
            traffic_window = tk.Toplevel(self.root)
            traffic_window.title("Network Traffic Monitor")
            traffic_window.geometry("1280x800")
            traffic_window.minsize(1024, 768)
            
            # Set the background color directly
            if self.dark_mode:
                bg_color = "#2d2d2d"
                traffic_window["bg"] = bg_color  # Use dictionary-style attribute setting
            
            # Configure for proper display
            configure_dialog_for_display(traffic_window)
            
            # Create main frame
            main_frame = ttk.Frame(traffic_window)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Import and initialize enhanced network monitor with visual graphs
            from src.enhanced_network_monitor import EnhancedNetworkMonitor
            
            # Initialize enhanced network monitor GUI with visualizations
            traffic_gui = EnhancedNetworkMonitor(
                main_frame,
                dark_mode=self.dark_mode,
                controller=self.controller
            )
            
            # Set current interface if available
            if hasattr(self, 'interface_var') and self.interface_var.get():
                current_interface = self.interface_var.get()
                traffic_gui.interface_var.set(current_interface)
            
            # Cleanup on close
            def on_dialog_close():
                if hasattr(traffic_gui, 'cleanup'):
                    traffic_gui.cleanup()
                traffic_window.destroy()
                
            traffic_window.protocol("WM_DELETE_WINDOW", on_dialog_close)
            
            # Log
            self.log("Opened Network Monitor", success=True)
        except Exception as e:
            self.log(f"Error showing Network Monitor: {str(e)}", error=True)
            messagebox.showerror("Error", f"Failed to display Network Monitor: {str(e)}")
    
    def show_advanced_reports(self, results=None):
        """Show advanced security reports with visual charts and graphs"""
        try:
            # Import required modules
            from datetime import datetime
            import os
            
            # Initialize report generator if needed
            if not hasattr(self, 'report_generator') or self.report_generator is None:
                from src.report_generator import ReportGenerator
                self.report_generator = ReportGenerator(controller=self.controller)
                
            # Store the results if provided
            if results:
                self.last_assessment_results = results
                
            # Create report window
            report_window = tk.Toplevel(self.root)
            report_window.title("Comprehensive Security Reports")
            report_window.geometry("1100x800")
            report_window.minsize(1024, 700)
            
            # Set the background color directly
            if self.dark_mode:
                bg_color = "#2d2d2d"
                report_window["bg"] = bg_color  # Use dictionary-style attribute setting
            
            # Configure for proper display
            configure_dialog_for_display(report_window)
            
            # Create title frame
            title_frame = ttk.Frame(report_window)
            title_frame.pack(fill=tk.X, padx=10, pady=5)
            
            ttk.Label(title_frame, text="Advanced Security Assessment Reports", 
                    font=("Helvetica", 14, "bold")).pack(side=tk.LEFT, padx=5)
            
            # Add maximize button
            max_btn = create_maximize_button(title_frame, report_window)
            max_btn.pack(side=tk.RIGHT, padx=5)
            
            # Create main frame for comprehensive report
            main_frame = ttk.Frame(report_window)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            # Setup advanced report tab with graphs, charts, and professional analysis
            self._setup_advanced_report_tab(main_frame)
            
            # Cleanup on close
            def on_dialog_close():
                self.log("Closed Advanced Reports window")
                report_window.destroy()
                
            report_window.protocol("WM_DELETE_WINDOW", on_dialog_close)
            
            # Log
            self.log("Opened Advanced Security Reports module", success=True)
        except Exception as e:
            self.log(f"Error showing advanced reports: {str(e)}", error=True)
            messagebox.showerror("Error", f"Failed to display advanced reports dialog: {str(e)}")
    
    def _setup_generate_report_tab(self, parent_frame):
        """Setup tab for direct report generation without preview"""
        # Main frame
        main_frame = ttk.Frame(parent_frame)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Info label
        ttk.Label(
            main_frame,
            text="Generate a security report with real assessment data",
            font=("Helvetica", 12, "bold")
        ).pack(pady=10)
        
        ttk.Label(
            main_frame,
            text="Choose a report type to generate immediately without preview.",
            wraplength=700
        ).pack(pady=5)
        
        # Company info frame
        info_frame = ttk.Frame(main_frame)
        info_frame.pack(fill=tk.X, pady=15)
        
        ttk.Label(info_frame, text="Client:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        company_entry = ttk.Entry(info_frame, width=30)
        company_entry.grid(row=0, column=1, sticky="w", padx=5, pady=5)
        company_entry.insert(0, "Client Organization")
        
        ttk.Label(info_frame, text="Security Analyst:").grid(row=1, column=0, sticky="w", padx=5, pady=5)
        analyst_entry = ttk.Entry(info_frame, width=30)
        analyst_entry.grid(row=1, column=1, sticky="w", padx=5, pady=5)
        analyst_entry.insert(0, "Security Analyst")
        
        # Report options frame
        options_frame = ttk.LabelFrame(main_frame, text="Report Options")
        options_frame.pack(fill=tk.X, pady=15)
        
        # Report type selection
        report_type_var = tk.StringVar(value="comprehensive")
        
        ttk.Radiobutton(
            options_frame,
            text="Simple Report - Basic text-based assessment results",
            variable=report_type_var,
            value="simple"
        ).pack(anchor=tk.W, padx=20, pady=5)
        
        ttk.Radiobutton(
            options_frame,
            text="Comprehensive Report - Detailed with charts, graphs and analysis",
            variable=report_type_var,
            value="comprehensive"
        ).pack(anchor=tk.W, padx=20, pady=5)
        
        # Include AI analysis option
        ai_var = tk.BooleanVar(value=True)
        ai_check = ttk.Checkbutton(
            options_frame,
            text="Include AI-enhanced analysis (uses online AI capabilities)",
            variable=ai_var
        )
        ai_check.pack(anchor=tk.W, padx=20, pady=10)
        
        # Section selection
        sections_frame = ttk.LabelFrame(main_frame, text="Include Sections")
        sections_frame.pack(fill=tk.X, pady=15)
        
        # Create section checkboxes in a grid
        scan_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(
            sections_frame,
            text="Network Scan Results",
            variable=scan_var
        ).grid(row=0, column=0, sticky="w", padx=20, pady=5)
        
        attack_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(
            sections_frame,
            text="Attack Results",
            variable=attack_var
        ).grid(row=0, column=1, sticky="w", padx=20, pady=5)
        
        traffic_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(
            sections_frame,
            text="Traffic Analysis",
            variable=traffic_var
        ).grid(row=1, column=0, sticky="w", padx=20, pady=5)
        
        post_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(
            sections_frame,
            text="Post-Exploitation Results",
            variable=post_var
        ).grid(row=1, column=1, sticky="w", padx=20, pady=5)
        
        # Generate button frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=20)
        
        # Status label
        status_var = tk.StringVar(value="Ready to generate report")
        status_label = ttk.Label(button_frame, textvariable=status_var)
        status_label.pack(side=tk.LEFT, pady=5)
        
        # Function to generate the selected report type
        def generate_selected_report():
            try:
                status_var.set("Preparing to generate report...")
                
                # Ask for save location
                filename = filedialog.asksaveasfilename(
                    title="Save Security Report",
                    defaultextension=".pdf",
                    filetypes=[("PDF Files", "*.pdf"), ("All Files", "*.*")]
                )
                
                if not filename:
                    status_var.set("Report generation cancelled")
                    return
                
                # Update status
                status_var.set("Generating report...")
                
                # Get selected report type
                report_type = report_type_var.get()
                
                company_name = company_entry.get()
                analyst_name = analyst_entry.get()
                
                if report_type == "simple":
                    # Generate simple report
                    try:
                        from src.report_generator import ReportGenerator
                        
                        # Initialize report generator if needed
                        report_gen = ReportGenerator(controller=self.controller)
                        
                        # Set company info
                        report_gen.set_company_info(company_name, analyst_name)
                        
                        # Generate report
                        report_file = report_gen.generate_pdf_report(output_filename=filename)
                        
                        if report_file:
                            self.log(f"Simple report generated: {report_file}", success=True)
                            messagebox.showinfo("Success", f"Simple report generated: {report_file}")
                            status_var.set("Simple report generated successfully")
                        else:
                            raise Exception("Failed to generate simple report")
                            
                    except Exception as e:
                        self.log(f"Error generating simple report: {str(e)}", error=True)
                        messagebox.showerror("Error", f"Failed to generate simple report: {str(e)}")
                        status_var.set(f"Error: {str(e)}")
                        
                elif report_type == "comprehensive":
                    # Generate comprehensive report
                    try:
                        from src.advanced_reports import ReportGenerator as AdvancedReportGenerator
                        
                        # Create advanced report generator
                        adv_report_gen = AdvancedReportGenerator(controller=self.controller)
                        
                        # Make sure data is loaded
                        adv_report_gen.load_data_from_controller()
                        
                        # Set company info
                        adv_report_gen.set_company_info(company_name, analyst_name)
                        
                        # Generate PDF report
                        adv_filename = adv_report_gen.generate_pdf_report(output_filename=filename)
                        
                        if adv_filename:
                            self.log(f"Comprehensive report generated: {adv_filename}", success=True)
                            messagebox.showinfo("Success", f"Comprehensive report generated: {adv_filename}")
                            status_var.set("Comprehensive report generated successfully")
                        else:
                            raise Exception("Failed to generate comprehensive report")
                            
                    except Exception as e:
                        self.log(f"Error generating comprehensive report: {str(e)}", error=True)
                        messagebox.showerror("Error", f"Failed to generate comprehensive report: {str(e)}")
                        status_var.set(f"Error: {str(e)}")
            
            except Exception as e:
                self.log(f"Error in report generation: {str(e)}", error=True)
                messagebox.showerror("Error", f"Report generation failed: {str(e)}")
                status_var.set(f"Error: {str(e)}")
        
        # Generate button
        generate_btn = ttk.Button(
            button_frame,
            text="Generate Selected Report",
            command=generate_selected_report,
            style="Report.TButton"
        )
        generate_btn.pack(side=tk.RIGHT, pady=5)
            
    def _setup_simple_report_tab(self, parent_frame):
        """Setup simple report tab with basic report options"""
        # Company info frame
        info_frame = ttk.Frame(parent_frame)
        info_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(info_frame, text="Client:").pack(side=tk.LEFT, padx=5)
        company_entry = ttk.Entry(info_frame, width=25)
        company_entry.pack(side=tk.LEFT, padx=5)
        company_entry.insert(0, "Client Organization")
        
        ttk.Label(info_frame, text="Security Analyst:").pack(side=tk.LEFT, padx=5)
        analyst_entry = ttk.Entry(info_frame, width=25)
        analyst_entry.pack(side=tk.LEFT, padx=5)
        analyst_entry.insert(0, "Security Analyst")
        
        # Main content frame
        content_frame = ttk.Frame(parent_frame)
        content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Update button
        def update_info():
            # Check if report generator exists
            if hasattr(self, 'report_generator') and self.report_generator:
                self.report_generator.set_company_info(
                    company_entry.get(),
                    analyst_entry.get()
                )
                # Clear and recreate the report preview
                for widget in content_frame.winfo_children():
                    widget.destroy()
                self.report_generator.create_report_preview(content_frame)
            else:
                self.log("Report generator not initialized", error=True)
                
        update_btn = ttk.Button(info_frame, text="Update Info", command=update_info)
        update_btn.pack(side=tk.LEFT, padx=10)
        
        # Generate PDF button
        def generate_pdf():
            # Check if report generator exists
            if hasattr(self, 'report_generator') and self.report_generator:
                self.report_generator.set_company_info(
                    company_entry.get(),
                    analyst_entry.get()
                )
                
                try:
                    output_file = self.report_generator.generate_pdf_report()
                    self.log(f"Generated simple PDF report: {output_file}", success=True)
                    messagebox.showinfo(
                        "Report Generated", 
                        f"Simple PDF Report successfully generated and saved to:\n{output_file}"
                    )
                    # Ask to open the report
                    if messagebox.askyesno("Report Generated", "Open the report now?"):
                        import webbrowser
                        webbrowser.open(output_file)
                except Exception as e:
                    self.log(f"Error generating simple PDF report: {str(e)}", error=True)
                    messagebox.showerror(
                        "Report Error", 
                        f"An error occurred while generating the report: {str(e)}"
                    )
            else:
                self.log("Report generator not initialized", error=True)
                messagebox.showerror("Error", "Report generator not initialized")
                
        generate_btn = ttk.Button(
            info_frame,
            text="Generate Simple PDF Report",
            command=generate_pdf
        )
        generate_btn.pack(side=tk.RIGHT, padx=10)
        
        # Load data and create the report preview
        try:
            self.log("Loading data for simple security report...", phase="REPORT")
            # Check if report generator exists
            if hasattr(self, 'report_generator') and self.report_generator:
                self.report_generator.load_data_from_controller()
                self.report_generator.create_report_preview(content_frame)
                self.log("Simple report dashboard generated successfully", success=True, phase="REPORT")
            else:
                error_label = ttk.Label(
                    content_frame,
                    text="Error: Report generator not initialized",
                    foreground="red"
                )
                error_label.pack(expand=True)
        except Exception as e:
            self.log(f"Error creating simple report preview: {str(e)}", error=True)
            error_label = ttk.Label(
                content_frame,
                text=f"Error creating report preview: {str(e)}",
                foreground="red"
            )
            error_label.pack(expand=True)
    
    def _setup_advanced_report_tab(self, parent_frame):
        """Setup advanced report tab with comprehensive reporting options"""
        from datetime import datetime
        import os
        
        # Import unified AI helper if needed for reporting
        try:
            from src.comprehensive_report import ComprehensiveReport
        except ImportError as e:
            self.log(f"Error importing reporting modules: {e}", error=True)
            error_label = ttk.Label(
                parent_frame,
                text=f"Error: Could not load advanced reporting modules.\n{str(e)}",
                foreground="red"
            )
            error_label.pack(expand=True, pady=20)
            return
            
        # Settings and options frame
        options_frame = ttk.LabelFrame(parent_frame, text="Report Settings")
        options_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Client info
        info_frame = ttk.Frame(options_frame)
        info_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(info_frame, text="Client Organization:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        company_var = tk.StringVar(value="Client Organization")
        company_entry = ttk.Entry(info_frame, width=30, textvariable=company_var)
        company_entry.grid(row=0, column=1, sticky="w", padx=5, pady=2)
        
        ttk.Label(info_frame, text="Report Title:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        title_var = tk.StringVar(value="WiFi Security Assessment Report")
        title_entry = ttk.Entry(info_frame, width=50, textvariable=title_var)
        title_entry.grid(row=1, column=1, sticky="w", padx=5, pady=2, columnspan=2)
        
        # Report sections
        sections_frame = ttk.Frame(options_frame)
        sections_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(sections_frame, text="Include in Report:").grid(row=0, column=0, sticky="w", padx=5, pady=2, columnspan=3)
        
        # Create checkboxes for each section
        include_scan_var = tk.BooleanVar(value=True)
        include_scan_cb = ttk.Checkbutton(sections_frame, text="Network Scan Results", variable=include_scan_var)
        include_scan_cb.grid(row=1, column=0, sticky="w", padx=5, pady=2)
        
        include_attacks_var = tk.BooleanVar(value=True)
        include_attacks_cb = ttk.Checkbutton(sections_frame, text="Attack Results", variable=include_attacks_var)
        include_attacks_cb.grid(row=1, column=1, sticky="w", padx=5, pady=2)
        
        include_traffic_var = tk.BooleanVar(value=True)
        include_traffic_cb = ttk.Checkbutton(sections_frame, text="Traffic Analysis", variable=include_traffic_var)
        include_traffic_cb.grid(row=1, column=2, sticky="w", padx=5, pady=2)
        
        include_post_var = tk.BooleanVar(value=True)
        include_post_cb = ttk.Checkbutton(sections_frame, text="Post-Exploitation Results", variable=include_post_var)
        include_post_cb.grid(row=2, column=0, sticky="w", padx=5, pady=2)
        
        include_vulns_var = tk.BooleanVar(value=True)
        include_vulns_cb = ttk.Checkbutton(sections_frame, text="Vulnerabilities", variable=include_vulns_var)
        include_vulns_cb.grid(row=2, column=1, sticky="w", padx=5, pady=2)
        
        include_rec_var = tk.BooleanVar(value=True)
        include_rec_cb = ttk.Checkbutton(sections_frame, text="Recommendations", variable=include_rec_var)
        include_rec_cb.grid(row=2, column=2, sticky="w", padx=5, pady=2)
        
        # AI Enhancement option
        ai_frame = ttk.Frame(options_frame)
        ai_frame.pack(fill=tk.X, padx=5, pady=5)
        
        use_ai_var = tk.BooleanVar(value=True)
        use_ai_cb = ttk.Checkbutton(ai_frame, text="Use AI to enhance report (requires API key for online mode)", variable=use_ai_var)
        use_ai_cb.pack(side=tk.LEFT, padx=5, pady=2)
        
        # Preview frame
        preview_frame = ttk.LabelFrame(parent_frame, text="Report Preview")
        preview_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Create a Text widget for the preview with scrollbar
        preview_text = tk.Text(preview_frame, wrap=tk.WORD, height=15, width=80)
        preview_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        preview_scroll = ttk.Scrollbar(preview_frame, command=preview_text.yview)
        preview_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        preview_text.config(yscrollcommand=preview_scroll.set)
        
        # Make text read-only
        preview_text.config(state=tk.DISABLED)
        
        # Status bar
        status_var = tk.StringVar(value="Ready")
        status_bar = ttk.Label(parent_frame, textvariable=status_var, relief=tk.SUNKEN, anchor=tk.W)
        status_bar.pack(fill=tk.X, padx=10, pady=2)
        
        # Create a function to update the preview
        def update_preview():
            status_var.set("Generating preview...")
            preview_text.config(state=tk.NORMAL)
            preview_text.delete(1.0, tk.END)
            
            try:
                # Create report instance
                report = ComprehensiveReport()
                
                # Set metadata
                report.set_metadata(
                    company_name=company_var.get(),
                    report_title=title_var.get()
                )
                
                # Generate a preview
                preview = f"# {title_var.get()}\n\n"
                preview += f"Prepared for: {company_var.get()}\n"
                preview += f"Date: {datetime.now().strftime('%Y-%m-%d')}\n\n"
                
                preview += "## Executive Summary\n\n"
                preview += "This comprehensive security assessment report provides an analysis of the wireless network security posture "
                preview += "based on the scans, tests, and analysis performed. The report includes detailed findings, risk scoring, and "
                preview += "actionable recommendations.\n\n"
                
                # Collect data
                if hasattr(self, 'controller'):
                    # Network scan data
                    if include_scan_var.get() and hasattr(self.controller, 'scan_results'):
                        ap_count = len(self.controller.scan_results) if self.controller.scan_results else 0
                        preview += f"## Network Scan Results\n\n"
                        preview += f"* Discovered {ap_count} WiFi networks in range\n"
                        
                        encryption_types = {}
                        for ap in self.controller.scan_results:
                            enc_type = ap.get("encryption", "Unknown")
                            encryption_types[enc_type] = encryption_types.get(enc_type, 0) + 1
                        
                        for enc_type, count in encryption_types.items():
                            preview += f"* {enc_type} encryption: {count} networks\n"
                        preview += "\n"
                    
                    # Attack results
                    if include_attacks_var.get() and hasattr(self.controller, 'attack_results'):
                        attack_count = len(self.controller.attack_results) if self.controller.attack_results else 0
                        preview += f"## Attack Results\n\n"
                        preview += f"* Conducted {attack_count} security tests\n"
                        
                        successful_attacks = 0
                        for attack in self.controller.attack_results:
                            if attack.get("success", False):
                                successful_attacks += 1
                        
                        preview += f"* Successful attacks: {successful_attacks}\n\n"
                    
                    # Traffic analysis
                    if include_traffic_var.get() and hasattr(self.controller, 'traffic_monitor'):
                        preview += f"## Traffic Analysis\n\n"
                        preview += "* Analyzed network traffic for security issues and sensitive data\n"
                        
                        if hasattr(self.controller.traffic_monitor, 'sensitive_data_alerts'):
                            sensitive_count = len(self.controller.traffic_monitor.sensitive_data_alerts)
                            preview += f"* Detected {sensitive_count} instances of sensitive data exposure\n\n"
                    
                    # Post-exploitation
                    if include_post_var.get() and hasattr(self.controller, 'post_exploitation'):
                        preview += f"## Post-Exploitation Findings\n\n"
                        
                        post_module = self.controller.post_exploitation
                        if hasattr(post_module, 'hosts'):
                            host_count = len(post_module.hosts)
                            preview += f"* Discovered {host_count} hosts during post-exploitation\n"
                            
                            vuln_count = 0
                            for host in post_module.hosts:
                                if hasattr(host, 'vulnerabilities'):
                                    vuln_count += len(host.vulnerabilities)
                            
                            preview += f"* Identified {vuln_count} vulnerabilities across all hosts\n\n"
                
                # Risk Scoring
                preview += "## Risk Assessment\n\n"
                preview += "The security assessment identified various risk factors in the following categories:\n\n"
                preview += "* Network Exposure: MEDIUM\n"
                preview += "* Authentication: HIGH\n"
                preview += "* Encryption: MEDIUM\n"
                preview += "* Vulnerabilities: HIGH\n"
                preview += "* Sensitive Data: MEDIUM\n\n"
                
                # Recommendations
                if include_rec_var.get():
                    preview += "## Recommendations\n\n"
                    preview += "Based on the assessment findings, we recommend the following actions:\n\n"
                    preview += "1. Replace WEP encryption with WPA2/WPA3 on all access points\n"
                    preview += "2. Implement strong password policies for all WiFi networks\n"
                    preview += "3. Disable WPS on all access points\n"
                    preview += "4. Apply security patches to all vulnerable systems\n"
                    preview += "5. Encrypt all sensitive data during transmission\n\n"
                
                # AI Enhancement note
                if use_ai_var.get():
                    preview += "Note: The final report will include AI-enhanced analysis and recommendations.\n\n"
                
                preview += "The comprehensive PDF report will include detailed findings, charts, and visualizations."
                
                # Update the preview text
                preview_text.insert(tk.END, preview)
                
                status_var.set("Preview generated successfully")
            except Exception as e:
                preview_text.insert(tk.END, f"Error generating preview: {str(e)}")
                status_var.set(f"Error: {str(e)}")
                self.log(f"Error generating advanced report preview: {str(e)}", error=True)
            
            preview_text.config(state=tk.DISABLED)
        
        # Create a function to generate the comprehensive PDF report
        def generate_comprehensive_report():
            status_var.set("Generating comprehensive PDF report...")
            
            try:
                # Get save location
                file_path = filedialog.asksaveasfilename(
                    title="Save Comprehensive Report",
                    defaultextension=".pdf",
                    filetypes=[("PDF files", "*.pdf")],
                    initialdir="reports"
                )
                
                if not file_path:
                    status_var.set("Report generation cancelled")
                    return
                
                # Create reports directory if it doesn't exist
                os.makedirs(os.path.dirname(file_path), exist_ok=True)
                
                # Create a report generator instance
                report = ComprehensiveReport()
                
                # Set metadata
                report.set_metadata(
                    company_name=company_var.get(),
                    report_title=title_var.get()
                )
                
                # Collect data from controller
                has_data = False
                
                if hasattr(self, 'controller'):
                    # Network scan data
                    if include_scan_var.get():
                        network_scan_data = self._collect_network_scan_data_for_report()
                        if network_scan_data:
                            report.add_network_scan_data(network_scan_data)
                            has_data = True
                    
                    # Attack data
                    if include_attacks_var.get():
                        attack_data = self._collect_attack_data_for_report()
                        for attack in attack_data:
                            report.add_attack_data(attack)
                            has_data = True
                    
                    # Traffic analysis data
                    if include_traffic_var.get():
                        traffic_data = self._collect_traffic_data_for_report()
                        if traffic_data:
                            report.add_traffic_analysis_data(traffic_data)
                            has_data = True
                    
                    # Post-exploitation data
                    if include_post_var.get():
                        post_data = self._collect_post_exploitation_data_for_report()
                        if post_data:
                            report.add_post_exploitation_data(post_data)
                            has_data = True
                    
                    # Vulnerabilities
                    if include_vulns_var.get():
                        vuln_data = self._collect_vulnerability_data_for_report()
                        for vuln in vuln_data:
                            report.add_vulnerability(vuln)
                            has_data = True
                
                if not has_data:
                    messagebox.showwarning(
                        "No Data Available", 
                        "No security data is available for the report. Please run scans and tests first."
                    )
                    status_var.set("No data available for report")
                    return
                
                # Generate recommendations
                if include_rec_var.get():
                    # Try to use AI for enhanced recommendations if requested
                    ai_assistant = None
                    if use_ai_var.get() and hasattr(self, 'unified_ai_helper'):
                        # Only use online AI assistant
                        if hasattr(self.unified_ai_helper, 'online_assistant'):
                            ai_assistant = self.unified_ai_helper.online_assistant
                    
                    report.generate_recommendations(ai_assistant)
                
                # Generate charts for visualization
                report.generate_charts()
                
                # Generate the PDF report
                status_var.set("Creating comprehensive PDF report...")
                report_path = report.generate_pdf_report(file_path)
                
                if report_path and os.path.exists(report_path):
                    self.log(f"Generated comprehensive security report: {report_path}", success=True)
                    messagebox.showinfo(
                        "Report Generated", 
                        f"Comprehensive security report successfully generated and saved to:\n{report_path}"
                    )
                    
                    # Ask to open the report
                    if messagebox.askyesno("Report Generated", "Open the report now?"):
                        import webbrowser
                        webbrowser.open(report_path)
                    
                    status_var.set(f"Report saved to: {report_path}")
                else:
                    messagebox.showerror("Report Generation Failed", "Failed to generate report")
                    status_var.set("Report generation failed")
            except Exception as e:
                messagebox.showerror("Error", f"Report generation failed: {str(e)}")
                status_var.set(f"Error: {str(e)}")
                self.log(f"Error generating comprehensive report: {str(e)}", error=True)
        
        # Create buttons for preview and generation
        button_frame = ttk.Frame(parent_frame)
        button_frame.pack(fill=tk.X, padx=10, pady=10)
        
        preview_btn = ttk.Button(
            button_frame,
            text="Update Preview",
            command=update_preview
        )
        preview_btn.pack(side=tk.LEFT, padx=5)
        
        generate_btn = ttk.Button(
            button_frame,
            text="Generate Comprehensive PDF Report",
            command=generate_comprehensive_report,
            style="Report.TButton"  # Use the report button style
        )
        generate_btn.pack(side=tk.RIGHT, padx=5)
        
        # Update the preview initially
        update_preview()
    
    def _collect_network_scan_data_for_report(self):
        """Collect network scan data for comprehensive report"""
        try:
            if hasattr(self, 'controller') and self.controller:
                # Check if controller has access to scan results
                if hasattr(self.controller, 'scan_results') and self.controller.scan_results:
                    ap_list = []
                    for ap in self.controller.scan_results:
                        ap_data = {
                            "ssid": ap.get("essid", "Unknown"),
                            "bssid": ap.get("bssid", "Unknown"),
                            "channel": ap.get("channel", 0),
                            "signal": ap.get("power", 0),
                            "encryption": ap.get("encryption", "Unknown"),
                            "wps_enabled": ap.get("wps", False),
                            "clients": len(ap.get("clients", []))
                        }
                        ap_list.append(ap_data)
                    
                    # Check if hosts are available
                    hosts_list = []
                    if hasattr(self.controller, 'hosts') and self.controller.hosts:
                        for host in self.controller.hosts:
                            host_data = {
                                "ip": host.get("ip", "Unknown"),
                                "hostname": host.get("hostname", "Unknown"),
                                "mac": host.get("mac", "Unknown"),
                                "vendor": host.get("vendor", "Unknown"),
                                "os": host.get("os", "Unknown"),
                                "open_ports": host.get("open_ports", [])
                            }
                            hosts_list.append(host_data)
                    
                    return {
                        "access_points": ap_list,
                        "hosts": hosts_list
                    }
            
            return None
        except Exception as e:
            self.log(f"Error collecting network scan data for report: {str(e)}", error=True)
            return None
    
    def _collect_attack_data_for_report(self):
        """Collect attack data for comprehensive report"""
        try:
            attacks = []
            if hasattr(self, 'controller') and self.controller:
                # Check if controller has access to attack results
                if hasattr(self.controller, 'attack_results') and self.controller.attack_results:
                    for attack in self.controller.attack_results:
                        attack_data = {
                            "type": attack.get("type", "Unknown"),
                            "target": attack.get("target", "Unknown"),
                            "ssid": attack.get("ssid", "Unknown"),
                            "success": attack.get("success", False),
                            "details": attack.get("details", "No details available"),
                            "time_taken": attack.get("time_taken", "Unknown")
                        }
                        
                        # Add specific attack data
                        if attack.get("type") == "wpa_handshake" and attack.get("success"):
                            attack_data["password"] = attack.get("password", "Unknown")
                        
                        if attack.get("type") == "deauth" and attack.get("success"):
                            attack_data["affected_clients"] = attack.get("affected_clients", 0)
                        
                        attacks.append(attack_data)
            
            return attacks
        except Exception as e:
            self.log(f"Error collecting attack data for report: {str(e)}", error=True)
            return []
    
    def _collect_traffic_data_for_report(self):
        """Collect traffic analysis data for comprehensive report"""
        try:
            if hasattr(self, 'controller') and self.controller:
                # Check if controller has traffic monitor data
                if hasattr(self.controller, 'traffic_monitor') and self.controller.traffic_monitor:
                    traffic_monitor = self.controller.traffic_monitor
                    
                    # Collect stats
                    stats = {
                        "total_packets": traffic_monitor.total_packets if hasattr(traffic_monitor, 'total_packets') else 0,
                        "total_bytes": traffic_monitor.total_bytes if hasattr(traffic_monitor, 'total_bytes') else 0,
                        "total_hosts": len(traffic_monitor.ip_stats) if hasattr(traffic_monitor, 'ip_stats') else 0
                    }
                    
                    # Collect protocol stats
                    protocol_stats = traffic_monitor.protocol_stats if hasattr(traffic_monitor, 'protocol_stats') else {}
                    
                    # Collect sensitive data findings
                    sensitive_data = []
                    if hasattr(traffic_monitor, 'sensitive_data_alerts'):
                        for alert in traffic_monitor.sensitive_data_alerts:
                            sensitive_data.append({
                                "type": alert.get("type", "Unknown"),
                                "protocol": alert.get("protocol", "Unknown"),
                                "source": alert.get("source", "Unknown"),
                                "destination": alert.get("destination", "Unknown"),
                                "details": alert.get("description", "No details available")
                            })
                    
                    # Check for unencrypted protocols
                    unencrypted_protocols = []
                    if protocol_stats:
                        for protocol in ["HTTP", "FTP", "TELNET", "SMTP", "POP3", "SNMP"]:
                            if protocol in protocol_stats and protocol_stats[protocol] > 0:
                                unencrypted_protocols.append(protocol)
                    
                    # Check for unusual traffic
                    unusual_traffic = []
                    if hasattr(traffic_monitor, 'traffic_alerts'):
                        for alert in traffic_monitor.traffic_alerts:
                            unusual_traffic.append({
                                "type": alert.get("type", "Unknown activity"),
                                "description": alert.get("description", "No details available")
                            })
                    
                    return {
                        "stats": stats,
                        "protocol_stats": protocol_stats,
                        "sensitive_data_found": sensitive_data,
                        "unencrypted_protocols": unencrypted_protocols,
                        "unusual_traffic": unusual_traffic
                    }
            
            return None
        except Exception as e:
            self.log(f"Error collecting traffic analysis data for report: {str(e)}", error=True)
            return None
    
    def _collect_post_exploitation_data_for_report(self):
        """Collect post-exploitation data for comprehensive report"""
        try:
            if hasattr(self, 'controller') and self.controller:
                # Check if controller has post-exploitation module
                if hasattr(self.controller, 'post_exploitation') and self.controller.post_exploitation:
                    post_module = self.controller.post_exploitation
                    
                    # Network map
                    network_map = {
                        "gateway": post_module.gateway_ip if hasattr(post_module, 'gateway_ip') else "Unknown",
                        "subnet": post_module.subnet if hasattr(post_module, 'subnet') else "Unknown",
                        "dhcp_server": post_module.dhcp_server if hasattr(post_module, 'dhcp_server') else "Unknown",
                        "dns_servers": post_module.dns_servers if hasattr(post_module, 'dns_servers') else []
                    }
                    
                    # Hosts
                    hosts = []
                    if hasattr(post_module, 'hosts') and post_module.hosts:
                        for host in post_module.hosts:
                            host_data = {
                                "ip": host.ip if hasattr(host, 'ip') else "Unknown",
                                "hostname": host.hostname if hasattr(host, 'hostname') else "Unknown",
                                "os": host.os if hasattr(host, 'os') else "Unknown",
                                "type": host.type if hasattr(host, 'type') else "unknown",
                                "compromised": host.compromised if hasattr(host, 'compromised') else False,
                                "access_level": host.access_level if hasattr(host, 'access_level') else "None"
                            }
                            
                            # Vulnerabilities
                            if hasattr(host, 'vulnerabilities') and host.vulnerabilities:
                                host_data["vulnerabilities"] = host.vulnerabilities
                            
                            # Default credentials
                            if hasattr(host, 'default_credentials'):
                                host_data["default_credentials"] = host.default_credentials
                            
                            # Missing patches
                            if hasattr(host, 'missing_patches') and host.missing_patches:
                                host_data["missing_patches"] = host.missing_patches
                            
                            # Privilege escalation
                            if hasattr(host, 'privilege_escalation') and host.privilege_escalation:
                                host_data["privilege_escalation"] = host.privilege_escalation
                            
                            hosts.append(host_data)
                    
                    # Lateral movement
                    lateral_movement = {
                        "successful": False
                    }
                    if hasattr(post_module, 'lateral_movement') and post_module.lateral_movement:
                        lateral_movement = post_module.lateral_movement
                    
                    return {
                        "network_map": network_map,
                        "hosts": hosts,
                        "lateral_movement": lateral_movement
                    }
            
            return None
        except Exception as e:
            self.log(f"Error collecting post-exploitation data for report: {str(e)}", error=True)
            return None
    
    def _collect_vulnerability_data_for_report(self):
        """Collect vulnerability data for comprehensive report"""
        try:
            # Collected vulnerabilities
            vulnerabilities = []
            
            # Try to collect from controller
            if hasattr(self, 'controller') and self.controller:
                # Check if controller has vulnerability data
                if hasattr(self.controller, 'vulnerabilities') and self.controller.vulnerabilities:
                    vulnerabilities.extend(self.controller.vulnerabilities)
            
            return vulnerabilities
        except Exception as e:
            self.log(f"Error collecting vulnerability data for report: {str(e)}", error=True)
            return []
        
    def show_post_exploitation(self):
        """Open the post-exploitation module interface"""
        # Create a new toplevel window for the post-exploitation module
        post_window = tk.Toplevel(self.root)
        post_window.title("Post-Exploitation Module")
        post_window.geometry("1000x700")
        post_window.transient(self.root)
        post_window.grab_set()
        
        # Apply theme to dialog
        if self.dark_mode:
            post_window.configure(bg="#2d2d2d")  # Changed from background to bg
        
        # Configure for proper display
        configure_dialog_for_display(post_window)
        
        # Make sure cracked_networks list exists
        if not hasattr(self, 'cracked_networks'):
            self.cracked_networks = []
        
        # Create post-exploitation interface and pass the controller and main GUI
        post_gui = PostExploitationGUI(post_window, self.root, self.dark_mode, controller=self)
        
        # Get cracked networks from any sources and add them as well
        if hasattr(self, 'cracked_networks'):
            for network in self.cracked_networks:
                if isinstance(network, dict):
                    ssid = network.get('ssid', 'Unknown')
                    password = network.get('password', '')
                    security = network.get('security', 'WPA2') 
                    post_gui.add_cracked_network(ssid, password, security)
                elif isinstance(network, tuple) and len(network) >= 2:
                    # Support for tuple format (ssid, password, [security_type])
                    ssid, password = network[0], network[1]
                    security = network[2] if len(network) > 2 else "WPA2"
                    post_gui.add_cracked_network(ssid, password, security)
        
        # Also try the controller's method if it exists
        if hasattr(self.controller, 'get_cracked_networks'):
            try:
                controller_networks = self.controller.get_cracked_networks()
                if controller_networks:
                    for network in controller_networks:
                        ssid = network.get('ssid', 'Unknown')
                        password = network.get('password', '')
                        security = network.get('security', 'WPA2')
                        post_gui.add_cracked_network(ssid, password, security)
            except Exception as e:
                print(f"Error getting networks from controller: {str(e)}")
    
    def show_help_dialog(self):
        """Show the help dialog with usage instructions"""
        # Create help window
        help_window = tk.Toplevel(self.root)
        help_window.title("WiFi Penetration Testing Tool - Help")
        help_window.geometry("700x600")
        help_window.resizable(True, True)
        
        # Apply theme to help window
        bg = "#2d2d2d" if self.dark_mode else "#f0f0f0"
        fg = "#ffffff" if self.dark_mode else "#000000"
        help_window.configure(bg=bg)
        
        # Create a title frame for the maximize button
        title_frame = ttk.Frame(help_window)
        title_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # Add title label
        ttk.Label(title_frame, text="Help & Documentation", 
                 font=("Helvetica", 14, "bold")).pack(side=tk.LEFT, padx=5)
        
        # Add maximize button
        max_btn = create_maximize_button(title_frame, help_window)
        max_btn.pack(side=tk.RIGHT, padx=5)
        
        # Configure proper display
        help_window.after(10, lambda: configure_dialog_for_display(help_window))
        
        # Create notebook for different help sections
        notebook = ttk.Notebook(help_window)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # 1. Getting Started section
        getting_started = ttk.Frame(notebook, padding="10")
        notebook.add(getting_started, text="Getting Started")
        
        start_text = ScrolledText(getting_started, wrap=tk.WORD, width=70, height=25)
        start_text.pack(fill=tk.BOTH, expand=True)
        start_text.insert(tk.END, """
GETTING STARTED WITH WIFI PENETRATION TESTING TOOL
=========================================================================

This tool performs real-world wireless network security assessments. Follow these steps to use it effectively:

1. PREREQUISITES
   ‚Ä¢ This tool must be run with root privileges (sudo)
   ‚Ä¢ You need a wireless adapter that supports monitor mode
   ‚Ä¢ Ensure you're using Kali Linux or a similar penetration testing environment

2. BASIC WORKFLOW
   ‚Ä¢ Select a wireless interface from the dropdown menu
   ‚Ä¢ Click Scan to discover nearby wireless networks
   ‚Ä¢ Select a network from the list for detailed information
   ‚Ä¢ Choose an appropriate attack method based on the network type
   ‚Ä¢ Generate a report after testing is complete

3. SCAN SETTINGS
   ‚Ä¢ Default scan time is 60 seconds (longer = more thorough)
   ‚Ä¢ Scan discovers networks, connected clients, and attempts to detect device types
   ‚Ä¢ Networks are sorted by signal strength (strongest first)

4. ATTACK GUIDANCE
   ‚Ä¢ Only test networks you own or have explicit permission to test
   ‚Ä¢ Different attacks work better on different network types
   ‚Ä¢ WPS attacks only work against routers with WPS enabled
   ‚Ä¢ WPA handshake attacks require active clients on the network
   ‚Ä¢ IoT attacks work best against known device brands and models

5. REPORT GENERATION
   ‚Ä¢ Reports contain detailed findings and security recommendations
   ‚Ä¢ PDF reports can be saved to any location
   ‚Ä¢ Include all test results and vulnerabilities discovered

IMPORTANT: Using this tool against networks without authorization is illegal in most jurisdictions.
""")
        start_text.config(state=tk.DISABLED)  # Make read-only
        
        # 2. Attack Guide section
        attack_guide = ttk.Frame(notebook, padding="10")
        notebook.add(attack_guide, text="Attack Guide")
        
        attack_text = ScrolledText(attack_guide, wrap=tk.WORD, width=70, height=25)
        attack_text.pack(fill=tk.BOTH, expand=True)
        attack_text.insert(tk.END, """
ATTACK METHOD GUIDANCE
====================

This tool implements multiple attack vectors. Choose the appropriate method for the target network:

1. WPA/WPA2 HANDSHAKE CAPTURE
   BEST FOR: Any WPA/WPA2 network with connected clients
   PROCESS:
   ‚Ä¢ Tool sends deauthentication packets to disconnect clients
   ‚Ä¢ When clients reconnect, the 4-way handshake is captured
   ‚Ä¢ The captured handshake can be used for offline password cracking
   REQUIREMENTS:
   ‚Ä¢ Active clients must be connected to the network
   ‚Ä¢ Clients must reconnect after deauthentication
   SUCCESS RATE: Medium to High (depends on client presence)

2. WPS PIN ATTACK
   BEST FOR: Networks with WPS enabled, especially older routers
   PROCESS:
   ‚Ä¢ Tool attempts to brute-force the 8-digit WPS PIN
   ‚Ä¢ Uses optimized algorithms to reduce attempt count
   ‚Ä¢ Once the PIN is found, the WPA password is retrieved
   REQUIREMENTS:
   ‚Ä¢ Target must have WPS enabled
   ‚Ä¢ Router must not implement proper rate limiting
   ‚Ä¢ Router must be vulnerable to external PIN brute-forcing
   SUCCESS RATE: Variable (newer routers have better protections)

3. WEP ATTACK
   BEST FOR: Networks using older WEP encryption
   PROCESS:
   ‚Ä¢ Collects initialization vectors (IVs) from the network
   ‚Ä¢ Uses statistical methods to determine the encryption key
   ‚Ä¢ Supports both active and passive attack methods
   REQUIREMENTS:
   ‚Ä¢ Network must use WEP encryption (rarely used nowadays)
   ‚Ä¢ Sufficient data packets must be captured
   SUCCESS RATE: High (WEP encryption is fundamentally flawed)

4. DEFAULT CREDENTIALS CHECK
   BEST FOR: IoT devices, IP cameras, and other smart devices
   PROCESS:
   ‚Ä¢ Tool identifies device type and vendor
   ‚Ä¢ Tests known default username/password combinations
   ‚Ä¢ Attempts to access device management interface
   REQUIREMENTS:
   ‚Ä¢ Device must be using factory default credentials
   ‚Ä¢ Device type must be recognized and in database
   SUCCESS RATE: High for unmodified devices, Low for secured ones

5. TEST ALL NETWORKS
   BEST FOR: Full security audits of multiple networks
   PROCESS:
   ‚Ä¢ Tests each detected network with the most appropriate method
   ‚Ä¢ Prioritizes networks by signal strength
   ‚Ä¢ Generates comprehensive report of all findings
   REQUIREMENTS:
   ‚Ä¢ Sufficient time to complete all tests
   ‚Ä¢ Various attack prerequisites for each network type
   SUCCESS RATE: Variable (depends on individual network security)

REMEMBER: Only use these attacks on networks you own or have explicit permission to test.
""")
        attack_text.config(state=tk.DISABLED)  # Make read-only
        
        # 3. Troubleshooting section
        troubleshooting = ttk.Frame(notebook, padding="10")
        notebook.add(troubleshooting, text="Troubleshooting")
        
        trouble_text = ScrolledText(troubleshooting, wrap=tk.WORD, width=70, height=25)
        trouble_text.pack(fill=tk.BOTH, expand=True)
        trouble_text.insert(tk.END, """
TROUBLESHOOTING GUIDE
===================

Common issues and their solutions:

1. NO WIRELESS INTERFACES FOUND
   Issue: The tool doesn't detect any wireless interfaces.
   Solutions:
   ‚Ä¢ Ensure you're running the tool with sudo privileges
   ‚Ä¢ Verify wireless adapter is connected properly
   ‚Ä¢ Check if drivers are properly installed
   ‚Ä¢ Run 'iw dev' or 'iwconfig' to see available interfaces
   ‚Ä¢ Some adapters may need firmware (check dmesg output)

2. MONITOR MODE FAILS
   Issue: Can't enable monitor mode on your wireless interface.
   Solutions:
   ‚Ä¢ Verify adapter supports monitor mode
   ‚Ä¢ Try killing conflicting processes: 'sudo airmon-ng check kill'
   ‚Ä¢ Try setting monitor mode manually: 'sudo ip link set wlan0 down && sudo iw wlan0 set monitor none && sudo ip link set wlan0 up'
   ‚Ä¢ Some adapters may show as wlan0mon in monitor mode

3. HANDSHAKE CAPTURE TROUBLESHOOTING
   Issue: Handshakes aren't being captured or are incomplete.
   Solutions:
   ‚Ä¢ Ensure there are active clients connected to the target network
   ‚Ä¢ Increase deauth packet count in Advanced Settings (5-10 packets)
   ‚Ä¢ Enable multi-burst deauthentication in Advanced Settings
   ‚Ä¢ Position yourself closer to both the AP and its clients
   ‚Ä¢ Try targeting specific clients rather than broadcast deauth
   ‚Ä¢ If you get partial handshakes (2-3 packets), they may still be usable
   ‚Ä¢ The retry functionality will automatically attempt multiple captures

3. NO NETWORKS FOUND DURING SCAN
   Issue: Scan completes but shows no wireless networks.
   Solutions:
   ‚Ä¢ Verify wireless adapter is functioning properly
   ‚Ä¢ Increase scan time for more thorough scanning
   ‚Ä¢ Try changing your physical location
   ‚Ä¢ Check if adapter supports scanning on all channels

4. HANDSHAKE CAPTURE FAILS
   Issue: Unable to capture WPA handshake.
   Solutions:
   ‚Ä¢ Verify clients are connected to the target network
   ‚Ä¢ Increase deauthentication packet count
   ‚Ä¢ Try closer physical proximity to the target
   ‚Ä¢ Some clients may be resistant to deauthentication

5. WPS ATTACK NOT WORKING
   Issue: WPS PIN attack doesn't make progress.
   Solutions:
   ‚Ä¢ Verify router has WPS enabled
   ‚Ä¢ The router may have rate limiting or lockout protection
   ‚Ä¢ Try increasing the timeout value
   ‚Ä¢ Some routers disable WPS after failed attempts

6. GUI DISPLAY ISSUES
   Issue: Interface elements appear incorrectly.
   Solutions:
   ‚Ä¢ Try toggling between light and dark theme
   ‚Ä¢ Ensure your screen resolution is at least 1024x768
   ‚Ä¢ Restart the application
   ‚Ä¢ Check for Python/Tkinter version compatibility

For additional support, check the documentation or submit an issue on the repository.
""")
        trouble_text.config(state=tk.DISABLED)  # Make read-only
        
        # Add close button
        close_btn = ttk.Button(help_window, text="Close", command=help_window.destroy)
        close_btn.pack(pady=10)
        
    def show_advanced_dialog(self):
        """Create a simplified advanced options dialog with lazy tab loading"""
        # Create dialog window
        dialog = tk.Toplevel(self.root)
        dialog.title("Advanced Options")
        dialog.geometry("800x600")
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Apply theme
        bg = "#2d2d2d" if self.dark_mode else "#f0f0f0"
        fg = "#ffffff" if self.dark_mode else "#000000"
        dialog.configure(bg=bg)
        
        # Header with maximize button
        header_frame = tk.Frame(dialog, bg=bg)
        header_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Title
        title_label = tk.Label(
            header_frame,
            text="Advanced Configuration",
            font=("Helvetica", 14, "bold"),
            bg=bg, fg=fg
        )
        title_label.pack(side=tk.LEFT, padx=10)
        
        # Maximize button
        max_btn = create_maximize_button(header_frame, dialog)
        max_btn.pack(side=tk.RIGHT, padx=5)
        
        # Create notebook with tabs
        notebook = ttk.Notebook(dialog)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Create tabs
        wpa_tab = ttk.Frame(notebook)
        wps_tab = ttk.Frame(notebook)
        wep_tab = ttk.Frame(notebook)
        default_creds_tab = ttk.Frame(notebook)
        scan_tab = ttk.Frame(notebook)
        interface_tab = ttk.Frame(notebook)
        settings_tab = ttk.Frame(notebook)
        about_tab = ttk.Frame(notebook)
        
        # Add tabs to notebook
        notebook.add(wpa_tab, text="WPA Attack")
        notebook.add(wps_tab, text="WPS Attack")
        notebook.add(wep_tab, text="WEP Attack")
        notebook.add(default_creds_tab, text="Default Credentials")
        notebook.add(scan_tab, text="Scanning")
        notebook.add(interface_tab, text="Interface Management")
        notebook.add(settings_tab, text="General Settings")
        notebook.add(about_tab, text="About")
        
        # Dictionary to track which tabs have been initialized
        tab_initialized = {tab: False for tab in [wpa_tab, wps_tab, wep_tab, default_creds_tab, 
                                               scan_tab, interface_tab, settings_tab, about_tab]}
        
        # Setup general settings and about tab immediately as they don't have wordlists
        self.setup_settings_tab(settings_tab)
        self.setup_about_tab(about_tab)
        tab_initialized[settings_tab] = True
        tab_initialized[about_tab] = True
        
        # Function to lazily load tab content when a tab is selected
        def on_tab_selected(event):
            selected_tab = event.widget.select()
            tab_id = event.widget.index(selected_tab)
            selected_tab_widget = [wpa_tab, wps_tab, wep_tab, default_creds_tab, 
                                 scan_tab, interface_tab, settings_tab, about_tab][tab_id]
            
            # Setup tab content only if not already initialized
            if not tab_initialized[selected_tab_widget]:
                if selected_tab_widget == wpa_tab:
                    self.setup_wpa_tab(wpa_tab)
                elif selected_tab_widget == wps_tab:
                    self.setup_wps_tab(wps_tab)
                elif selected_tab_widget == wep_tab:
                    self.setup_wep_tab(wep_tab)
                elif selected_tab_widget == default_creds_tab:
                    self.setup_default_creds_tab(default_creds_tab)
                elif selected_tab_widget == scan_tab:
                    self.setup_scan_tab(scan_tab)
                elif selected_tab_widget == interface_tab:
                    self.setup_interface_tab(interface_tab)
                
                tab_initialized[selected_tab_widget] = True
        
        # Bind tab change event to lazy loading function
        notebook.bind("<<NotebookTabChanged>>", on_tab_selected)
        
        # Button frame
        button_frame = tk.Frame(dialog, bg=bg)
        button_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Save button
        save_btn = ttk.Button(
            button_frame,
            text="Save Settings",
            command=lambda: self.save_advanced_settings(dialog)
        )
        save_btn.pack(side=tk.LEFT, padx=5)
        
        # Close button
        close_btn = ttk.Button(
            button_frame,
            text="Close",
            command=dialog.destroy
        )
        close_btn.pack(side=tk.RIGHT, padx=5)
        
        # Make sure it opens maximized
        dialog.update_idletasks()
        dialog.state('normal')
        
        return dialog
        
    def setup_wpa_tab(self, parent):
        """Setup WPA attack configuration tab"""
        # Timeout setting
        timeout_frame = ttk.Frame(parent)
        timeout_frame.pack(fill=tk.X, padx=20, pady=10)
        
        timeout_label = ttk.Label(timeout_frame, text="Capture Timeout (seconds):")
        timeout_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.wpa_timeout_var = tk.IntVar(value=self.controller.attack_params.wpa_timeout)
        timeout_spin = ttk.Spinbox(timeout_frame, from_=5, to=300, 
                                  textvariable=self.wpa_timeout_var, width=5)
        timeout_spin.pack(side=tk.LEFT)
        
        # Deauth packet count
        deauth_frame = ttk.Frame(parent)
        deauth_frame.pack(fill=tk.X, padx=20, pady=10)
        
        deauth_label = ttk.Label(deauth_frame, text="Deauthentication Packet Count:")
        deauth_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.deauth_count_var = tk.IntVar(value=self.controller.attack_params.deauth_packets)
        deauth_spin = ttk.Spinbox(deauth_frame, from_=1, to=20, 
                                 textvariable=self.deauth_count_var, width=5)
        deauth_spin.pack(side=tk.LEFT)
        
        # Wordlist selection
        wordlist_frame = ttk.Frame(parent)
        wordlist_frame.pack(fill=tk.X, padx=20, pady=10)
        
        wordlist_label = ttk.Label(wordlist_frame, text="WPA Wordlist:")
        wordlist_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.wpa_wordlist_var = tk.StringVar(value=self.controller.attack_params.wpa_wordlist)
        wordlist_entry = ttk.Entry(wordlist_frame, textvariable=self.wpa_wordlist_var, width=40)
        wordlist_entry.pack(side=tk.LEFT, padx=(0, 5), fill=tk.X, expand=True)
        
        wordlist_btn = ttk.Button(wordlist_frame, text="Browse...", 
                                 command=lambda: self.browse_file(self.wpa_wordlist_var))
        wordlist_btn.pack(side=tk.LEFT)
        
    def setup_wps_tab(self, parent):
        """Setup WPS attack configuration tab"""
        # Timeout setting
        timeout_frame = ttk.Frame(parent)
        timeout_frame.pack(fill=tk.X, padx=20, pady=10)
        
        timeout_label = ttk.Label(timeout_frame, text="WPS Attack Timeout (seconds):")
        timeout_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.wps_timeout_var = tk.IntVar(value=self.controller.attack_params.wps_timeout)
        timeout_spin = ttk.Spinbox(timeout_frame, from_=5, to=900, 
                                  textvariable=self.wps_timeout_var, width=5)
        timeout_spin.pack(side=tk.LEFT)
        
        # Pin attempts
        pin_frame = ttk.Frame(parent)
        pin_frame.pack(fill=tk.X, padx=20, pady=10)
        
        pin_label = ttk.Label(pin_frame, text="Max PIN Attempts:")
        pin_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.wps_pin_var = tk.IntVar(value=self.controller.attack_params.wps_pin_attempts)
        pin_spin = ttk.Spinbox(pin_frame, from_=1, to=100, 
                              textvariable=self.wps_pin_var, width=5)
        pin_spin.pack(side=tk.LEFT)
        
        # PIN list selection
        pin_list_frame = ttk.Frame(parent)
        pin_list_frame.pack(fill=tk.X, padx=20, pady=10)
        
        pin_list_label = ttk.Label(pin_list_frame, text="WPS PIN List:")
        pin_list_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.wps_pin_list_var = tk.StringVar(value=self.controller.attack_params.wps_pin_wordlist)
        pin_list_entry = ttk.Entry(pin_list_frame, textvariable=self.wps_pin_list_var, width=40)
        pin_list_entry.pack(side=tk.LEFT, padx=(0, 5), fill=tk.X, expand=True)
        
        pin_list_btn = ttk.Button(pin_list_frame, text="Browse...", 
                                 command=lambda: self.browse_file(self.wps_pin_list_var))
        pin_list_btn.pack(side=tk.LEFT)
        
    def setup_wep_tab(self, parent):
        """Setup WEP attack configuration tab"""
        # Timeout setting
        timeout_frame = ttk.Frame(parent)
        timeout_frame.pack(fill=tk.X, padx=20, pady=10)
        
        timeout_label = ttk.Label(timeout_frame, text="WEP Attack Timeout (seconds):")
        timeout_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.wep_timeout_var = tk.IntVar(value=self.controller.attack_params.wep_timeout)
        timeout_spin = ttk.Spinbox(timeout_frame, from_=5, to=900, 
                                  textvariable=self.wep_timeout_var, width=5)
        timeout_spin.pack(side=tk.LEFT)
        
        # IV goal
        iv_frame = ttk.Frame(parent)
        iv_frame.pack(fill=tk.X, padx=20, pady=10)
        
        iv_label = ttk.Label(iv_frame, text="IV Collection Goal:")
        iv_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.wep_iv_var = tk.IntVar(value=self.controller.attack_params.wep_iv_goal)
        iv_spin = ttk.Spinbox(iv_frame, from_=5000, to=100000, increment=5000,
                             textvariable=self.wep_iv_var, width=8)
        iv_spin.pack(side=tk.LEFT)
        
    def setup_pmkid_tab(self, parent):
        """PMKID attack module has been removed"""
        # Add placeholder message
        message_frame = ttk.Frame(parent)
        message_frame.pack(fill=tk.X, padx=20, pady=10)
        
        message_label = ttk.Label(message_frame, text="PMKID attack module has been removed from this version.")
        message_label.pack(side=tk.LEFT, padx=(0, 10))
        
    def setup_evil_twin_tab(self, parent):
        """Evil Twin attack module has been removed"""
        # Add placeholder message
        message_frame = ttk.Frame(parent)
        message_frame.pack(fill=tk.X, padx=20, pady=10)
        
        message_label = ttk.Label(message_frame, text="Evil Twin attack module has been removed from this version.")
        message_label.pack(side=tk.LEFT, padx=(0, 10))
        
    def setup_default_creds_tab(self, parent):
        """Setup default credentials check configuration tab"""
        # Credentials wordlist selection
        creds_frame = ttk.Frame(parent)
        creds_frame.pack(fill=tk.X, padx=20, pady=10)
        
        creds_label = ttk.Label(creds_frame, text="Default Credentials List:")
        creds_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.default_creds_list_var = tk.StringVar(value=self.controller.attack_params.default_creds_wordlist)
        creds_entry = ttk.Entry(creds_frame, textvariable=self.default_creds_list_var, width=40)
        creds_entry.pack(side=tk.LEFT, padx=(0, 5), fill=tk.X, expand=True)
        
        creds_btn = ttk.Button(creds_frame, text="Browse...", 
                              command=lambda: self.browse_file(self.default_creds_list_var))
        creds_btn.pack(side=tk.LEFT)
        
    def setup_scan_tab(self, parent):
        """Setup scan configuration tab"""
        # Channel hopping interval
        hop_frame = ttk.Frame(parent)
        hop_frame.pack(fill=tk.X, padx=20, pady=10)
        
        hop_label = ttk.Label(hop_frame, text="Channel Hop Interval (seconds):")
        hop_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.channel_hop_var = tk.DoubleVar(value=self.controller.attack_params.channel_hop_interval)
        hop_spin = ttk.Spinbox(hop_frame, from_=0.1, to=10.0, increment=0.1,
                              textvariable=self.channel_hop_var, width=5)
        hop_spin.pack(side=tk.LEFT)
        
        # Default scan time
        scan_time_frame = ttk.Frame(parent)
        scan_time_frame.pack(fill=tk.X, padx=20, pady=10)
        
        scan_time_label = ttk.Label(scan_time_frame, text="Default Scan Time (seconds):")
        scan_time_label.pack(side=tk.LEFT, padx=(0, 10))
        
        scan_time_spin = ttk.Spinbox(scan_time_frame, from_=5, to=300, 
                                    textvariable=self.scan_time_var, width=5)
        scan_time_spin.pack(side=tk.LEFT)
        
    def setup_interface_tab(self, parent):
        """Setup interface management tab"""
        # Interface check interval
        check_frame = ttk.Frame(parent)
        check_frame.pack(fill=tk.X, padx=20, pady=10)
        
        # Interface information
        info_frame = ttk.LabelFrame(parent, text="Interface Information")
        info_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        # Get current interface
        interface = self.interface_var.get()
        
        if interface:
            # Display interface info
            if self.is_dev_mode:
                # Simulated info
                info_text = f"""
Interface: {interface}
MAC Address: 00:11:22:33:44:55
Current Mode: {"Monitor" if "Monitor" in self.mode_btn["text"] else "Managed"}
Chipset: Simulated (Development Mode)
Driver: Simulated (Development Mode)
Monitor Support: Yes
Injection Support: Yes
                """
            else:
                # Get real info
                try:
                    # Get MAC address
                    cmd = ["ip", "link", "show", interface]
                    result = subprocess.run(cmd, capture_output=True, text=True)
                    mac_match = re.search(r"link/ether ([0-9a-f:]+)", result.stdout)
                    mac = mac_match.group(1) if mac_match else "Unknown"
                    
                    # Get mode
                    mode = SecurityUtils.get_interface_mode(interface)
                    
                    # Test injection capability
                    injection_success, _, injection_rate = SecurityUtils.test_packet_injection(interface)
                    
                    info_text = f"""
Interface: {interface}
MAC Address: {mac}
Current Mode: {mode.capitalize()}
Packet Injection: {"Yes" if injection_success else "No"}
Injection Rate: {injection_rate}%
                    """
                except Exception:
                    info_text = f"Error retrieving information for {interface}"
        else:
            info_text = "No interface selected"
            
        # Display info
        info_display = ScrolledText(info_frame, wrap=tk.WORD, height=10)
        info_display.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        info_display.insert(tk.END, info_text)
        info_display.config(state=tk.DISABLED)
        
        # Actions
        action_frame = ttk.LabelFrame(parent, text="Actions")
        action_frame.pack(fill=tk.X, padx=20, pady=10)
        
        # Monitor mode button
        monitor_btn = ttk.Button(action_frame, text="Toggle Monitor Mode", 
                                command=self.toggle_interface_mode)
        monitor_btn.pack(fill=tk.X, padx=10, pady=5)
        
        # Refresh button
        refresh_btn = ttk.Button(action_frame, text="Refresh Interfaces", 
                                command=self.refresh_interfaces)
        refresh_btn.pack(fill=tk.X, padx=10, pady=5)
        
        # Injection test button
        test_btn = ttk.Button(action_frame, text="Test Packet Injection", 
                             command=self.test_packet_injection)
        test_btn.pack(fill=tk.X, padx=10, pady=5)
        
    def test_packet_injection(self):
        """Test packet injection capability of current interface"""
        interface = self.interface_var.get()
        if not interface:
            messagebox.showerror("Error", "No interface selected")
            return
            
        if self.is_dev_mode:
            self.log("DEVELOPMENT MODE: Simulating packet injection test", warning=True)
            self.log("Packet injection test: 100% success rate (simulated)", success=True, phase="HARDWARE")
            messagebox.showinfo("Packet Injection Test", "Simulated test successful with 100% rate")
            return
            
        # Test injection
        self.log(f"Testing packet injection on {interface}...", phase="HARDWARE")
        success, msg, rate = SecurityUtils.test_packet_injection(interface, self.log)
        
        if success:
            messagebox.showinfo("Packet Injection Test", f"Test successful with {rate}% injection rate")
        else:
            messagebox.showerror("Packet Injection Test", f"Test failed: {msg}")
            
    def setup_settings_tab(self, parent):
        """Setup general settings tab"""
        # Title for settings section
        settings_title = ttk.Label(parent, text="Appearance Settings", font=("Helvetica", 14, "bold"))
        settings_title.pack(pady=(20, 10), padx=20, anchor=tk.W)
        
        # Theme selection with colorful button
        theme_frame = ttk.Frame(parent)
        theme_frame.pack(fill=tk.X, padx=20, pady=10)
        
        theme_label = ttk.Label(theme_frame, text="Theme:", font=("Helvetica", 11))
        theme_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.theme_var = tk.StringVar(value="Dark" if self.dark_mode else "Light")
        theme_combo = ttk.Combobox(theme_frame, textvariable=self.theme_var,
                                  values=["Dark", "Light"], width=10, state="readonly")
        theme_combo.pack(side=tk.LEFT)
        
        theme_apply = ttk.Button(theme_frame, text="Apply Theme", 
                                command=self.apply_theme_setting,
                                style="Settings.TButton")
        theme_apply.pack(side=tk.LEFT, padx=10)
        
        # Font size selection section
        font_frame = ttk.Frame(parent)
        font_frame.pack(fill=tk.X, padx=20, pady=10)
        
        font_label = ttk.Label(font_frame, text="UI Font Size:", font=("Helvetica", 11))
        font_label.pack(side=tk.LEFT, padx=(0, 10))
        
        # Font size options
        self.font_size_var = tk.StringVar(value="Medium")
        font_combo = ttk.Combobox(font_frame, textvariable=self.font_size_var,
                                 values=["Small", "Medium", "Large", "Extra Large"], 
                                 width=12, state="readonly")
        font_combo.pack(side=tk.LEFT)
        
        font_apply = ttk.Button(font_frame, text="Apply Font Size", 
                               command=self.apply_font_size_setting,
                               style="Settings.TButton")
        font_apply.pack(side=tk.LEFT, padx=10)
        
        # Console log font size selection section
        console_font_frame = ttk.Frame(parent)
        console_font_frame.pack(fill=tk.X, padx=20, pady=10)
        
        console_font_label = ttk.Label(console_font_frame, text="Console Log Font Size:", font=("Helvetica", 11))
        console_font_label.pack(side=tk.LEFT, padx=(0, 10))
        
        # Console log font size options
        self.console_font_size_var = tk.StringVar(value="Medium")
        console_font_combo = ttk.Combobox(console_font_frame, textvariable=self.console_font_size_var,
                                 values=["Small", "Medium", "Large", "Extra Large"], 
                                 width=12, state="readonly")
        console_font_combo.pack(side=tk.LEFT)
        
        console_font_apply = ttk.Button(console_font_frame, text="Apply Console Font Size", 
                               command=self.apply_console_font_size,
                               style="Settings.TButton")
        console_font_apply.pack(side=tk.LEFT, padx=10)
        
        # Font size preview
        preview_frame = ttk.LabelFrame(parent, text="Font Size Preview")
        preview_frame.pack(fill=tk.X, padx=20, pady=(20, 10), ipady=10)
        
        sample_text = "This is how text will appear throughout the application."
        self.font_preview = ttk.Label(preview_frame, text=sample_text, font=("Helvetica", 10))
        self.font_preview.pack(pady=10)
        
        # Console font size preview
        console_preview_frame = ttk.LabelFrame(parent, text="Console Log Font Size Preview")
        console_preview_frame.pack(fill=tk.X, padx=20, pady=(10, 10), ipady=10)
        
        console_sample_text = "[INFO] This is how log messages will appear in console."
        self.console_font_preview = tk.Text(console_preview_frame, height=2, width=40, wrap=tk.WORD)
        self.console_font_preview.insert(tk.END, console_sample_text)
        self.console_font_preview.tag_configure("info", foreground="green")
        self.console_font_preview.tag_add("info", "1.0", "1.6")
        self.console_font_preview.config(state=tk.DISABLED)
        self.console_font_preview.pack(pady=10, fill=tk.X)
        
        # Divider
        ttk.Separator(parent, orient=tk.HORIZONTAL).pack(fill=tk.X, padx=20, pady=15)
        
        # File paths section title
        paths_title = ttk.Label(parent, text="File Paths", font=("Helvetica", 14, "bold"))
        paths_title.pack(pady=(10, 10), padx=20, anchor=tk.W)
        
        # Report directory
        report_frame = ttk.Frame(parent)
        report_frame.pack(fill=tk.X, padx=20, pady=10)
        
        report_label = ttk.Label(report_frame, text="Report Directory:", font=("Helvetica", 11))
        report_label.pack(side=tk.LEFT, padx=(0, 10))
        
        self.report_dir_var = tk.StringVar(value="reports")
        report_entry = ttk.Entry(report_frame, textvariable=self.report_dir_var, width=40)
        report_entry.pack(side=tk.LEFT, padx=(0, 5), fill=tk.X, expand=True)
        
        report_btn = ttk.Button(report_frame, text="Browse...", 
                               command=lambda: self.browse_directory(self.report_dir_var),
                               style="Settings.TButton")
        report_btn.pack(side=tk.LEFT)
        
    def apply_theme_setting(self):
        """Apply theme from settings tab"""
        theme = self.theme_var.get()
        self.dark_mode = (theme == "Dark")
        self.apply_theme()
        
    def apply_font_size_setting(self):
        """Apply font size from settings tab"""
        size_name = self.font_size_var.get()
        # Convert size name to lowercase for theme manager
        size_key = size_name.lower().replace(" ", "_")
        
        # Update font preview
        font_sizes = {
            "small": 9,
            "medium": 10, 
            "large": 12,
            "extra_large": 14
        }
        preview_size = font_sizes.get(size_key, 10)
        self.font_preview.configure(font=("Helvetica", preview_size))
        
        # Apply font size to theme manager
        if hasattr(self, 'theme_manager'):
            self.theme_manager.set_font_size(size_key)
        
        # Update the theme to refresh all fonts
        self.apply_theme()
        
    def apply_console_font_size(self):
        """Apply selected font size specifically to console logs"""
        console_font_size = self.console_font_size_var.get()
        
        # Get font size mapping
        font_sizes = {
            "small": 9,
            "medium": 10, 
            "large": 12,
            "extra_large": 14
        }
        
        # Get the size key
        size_key = console_font_size.lower().replace(" ", "_")
        font_size = font_sizes.get(size_key, 10)
        
        # Update console preview
        self.console_font_preview.config(state=tk.NORMAL)
        font_family = "TkFixedFont"  # Use fixed-width font for console
        self.console_font_preview.configure(font=(font_family, font_size))
        self.console_font_preview.config(state=tk.DISABLED)
        
        # Update the actual console if it exists
        if hasattr(self, 'console'):
            self.console.config(font=(font_family, font_size))
            
        # Update any other log displays in the application
        if hasattr(self, 'post_exploitation_module') and hasattr(self.post_exploitation_module, 'output_text'):
            self.post_exploitation_module.output_text.config(font=(font_family, font_size))
            
        # Save the setting in config
        if not hasattr(self, 'config'):
            self.config = {}
        if 'appearance' not in self.config:
            self.config['appearance'] = {}
        self.config['appearance']['console_font_size'] = console_font_size
        self.save_config()
        
        # Show confirmation
        self.log(f"Console log font size set to {console_font_size}", success=True)
        
    def setup_about_tab(self, parent):
        """Setup about tab"""
        # About container
        about_container = ttk.Frame(parent)
        about_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # App logo
        logo_frame = ttk.Frame(about_container)
        logo_frame.pack(pady=20)
        
        # App title
        title_label = ttk.Label(about_container, 
                               text="WiFi Penetration Testing Tool", 
                               font=("Helvetica", 18, "bold"))
        title_label.pack(pady=10)
        
        # Version
        version_label = ttk.Label(about_container, 
                                 text="Version 3.0", 
                                 font=("Helvetica", 12))
        version_label.pack(pady=5)
        
        # Description
        desc_frame = ttk.Frame(about_container)
        desc_frame.pack(fill=tk.X, pady=20)
        
        desc_text = ttk.Label(desc_frame, 
                             text="""This tool is designed for security professionals to perform comprehensive 
wireless network assessments. It implements multiple attack vectors for 
testing the security of WiFi networks and connected devices.

IMPORTANT: Only use on networks you own or have explicit permission to test.
Unauthorized testing is illegal in most jurisdictions.""",
                             justify=tk.CENTER,
                             wraplength=500)
        desc_text.pack()
        
        # Credits
        credits_frame = ttk.LabelFrame(about_container, text="Credits")
        credits_frame.pack(fill=tk.X, pady=10)
        
        credits_text = ttk.Label(credits_frame, 
                               text="""This tool builds upon and incorporates many open-source tools including:
Aircrack-ng, Reaver, hcxdumptool, hostapd, dnsmasq, and many others.

Special thanks to the entire wireless security community.""",
                               justify=tk.LEFT,
                               wraplength=500)
        credits_text.pack(padx=10, pady=10)
        
    def browse_file(self, string_var):
        """Browse for file and update StringVar"""
        file_path = filedialog.askopenfilename()
        if file_path:
            string_var.set(file_path)
            
    def browse_directory(self, string_var):
        """Browse for directory and update StringVar"""
        dir_path = filedialog.askdirectory()
        if dir_path:
            string_var.set(dir_path)
            
    def save_advanced_settings(self, dialog):
        """Save advanced settings from dialog"""
        # Update attack parameters
        params = self.controller.attack_params
        
        # WPA settings
        params.wpa_timeout = self.wpa_timeout_var.get()
        params.deauth_packets = self.deauth_count_var.get()
        params.wpa_wordlist = self.wpa_wordlist_var.get()
        
        # WPS settings
        params.wps_timeout = self.wps_timeout_var.get()
        params.wps_pin_attempts = self.wps_pin_var.get()
        params.wps_pin_wordlist = self.wps_pin_list_var.get()
        
        # WEP settings
        params.wep_timeout = self.wep_timeout_var.get()
        params.wep_iv_goal = self.wep_iv_var.get()
        
        # PMKID and Evil Twin modules have been removed
        
        # Default creds settings
        params.default_creds_wordlist = self.default_creds_list_var.get()
        
        # Scan settings
        params.channel_hop_interval = int(self.channel_hop_var.get())
        
        # Update modules with new parameters
        for module in self.controller.attack_modules.values():
            module.attack_params = params
            
        # Save to config
        self.save_config()
        
        # Show confirmation
        messagebox.showinfo("Settings Saved", "Advanced settings have been saved successfully")
        
        # Close dialog
        dialog.destroy()
        
    def show_attack_all_dialog(self):
        """Show dialog for attacking all networks"""
        if not self.scan_results:
            messagebox.showerror("Error", "No networks found. Please scan first.")
            return
            
        # Sort networks by signal strength
        sorted_networks = sorted(self.scan_results, 
                                key=lambda x: getattr(x, 'signal_strength', 0), 
                                reverse=True)
        
        # Create dialog window
        dialog = tk.Toplevel(self.root)
        dialog.title("Auto Attack Sequencer")
        dialog.geometry("800x600")
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Apply theme
        bg = "#2d2d2d" if self.dark_mode else "#f0f0f0"
        fg = "#ffffff" if self.dark_mode else "#000000"
        dialog.configure(bg=bg)
        
        # Header with maximize button
        header_frame = tk.Frame(dialog, bg=bg)
        header_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Title
        title_label = tk.Label(
            header_frame,
            text="Automated Attack Sequence",
            font=("Helvetica", 14, "bold"),
            bg=bg, fg=fg
        )
        title_label.pack(side=tk.LEFT, padx=10)
        
        # Maximize button
        max_btn = create_maximize_button(header_frame, dialog)
        max_btn.pack(side=tk.RIGHT, padx=5)
        
        # Description
        desc_frame = tk.Frame(dialog, bg=bg)
        desc_frame.pack(fill=tk.X, padx=20, pady=10)
        
        network_count = len(sorted_networks)
        description = tk.Label(
            desc_frame,
            text=f"This will test {network_count} network{'s' if network_count != 1 else ''} in order of signal strength.",
            wraplength=700,
            bg=bg, fg=fg
        )
        description.pack(anchor=tk.W)
        
        # Network list
        list_frame = tk.LabelFrame(dialog, text="Networks to Test", bg=bg, fg=fg)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        # Create treeview
        columns = ("ssid", "bssid", "security", "signal")
        tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=8)
        
        # Configure columns
        tree.heading("ssid", text="Network Name")
        tree.heading("bssid", text="BSSID")
        tree.heading("security", text="Security")
        tree.heading("signal", text="Signal")
        
        tree.column("ssid", width=150)
        tree.column("bssid", width=150)
        tree.column("security", width=120)
        tree.column("signal", width=70)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=tree.yview)
        tree.configure(yscrollcommand=scrollbar.set)
        
        # Place treeview and scrollbar
        tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Fill treeview
        for net in sorted_networks:
            # Format security
            security = ", ".join(net.security) if net.security else "Open"
            
            # Add to treeview
            tree.insert("", tk.END, values=(
                net.ssid,
                net.bssid,
                security,
                f"{getattr(net, 'signal_strength', 0)}%" if hasattr(net, 'signal_strength') else "?"
            ))
        
        # Options
        options_frame = tk.LabelFrame(dialog, text="Attack Options", bg=bg, fg=fg)
        options_frame.pack(fill=tk.X, padx=20, pady=10)
        
        # Create columns for options
        opts_frame = tk.Frame(options_frame, bg=bg)
        opts_frame.pack(fill=tk.X, padx=10, pady=10)
        
        left_col = tk.Frame(opts_frame, bg=bg)
        left_col.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        right_col = tk.Frame(opts_frame, bg=bg)
        right_col.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        
        # Attack checkboxes
        def_creds_var = tk.BooleanVar(value=True)
        wps_var = tk.BooleanVar(value=True)
        wpa_var = tk.BooleanVar(value=True)
        wep_var = tk.BooleanVar(value=True)
        ip_detect_var = tk.BooleanVar(value=True)
        port_scan_var = tk.BooleanVar(value=True)
        
        # Variables defined for backward compatibility but not used (removed modules)
        pmkid_var = tk.BooleanVar(value=False)
        evil_twin_var = tk.BooleanVar(value=False)
        
        # Left column - 3 checkboxes
        def_creds_check = tk.Checkbutton(
            left_col,
            text="Default Credentials Check",
            variable=def_creds_var,
            bg=bg, fg=fg
        )
        def_creds_check.pack(anchor=tk.W, pady=2)
        
        wps_check = tk.Checkbutton(
            left_col,
            text="WPS PIN Attack",
            variable=wps_var,
            bg=bg, fg=fg
        )
        wps_check.pack(anchor=tk.W, pady=2)
        
        wpa_check = tk.Checkbutton(
            left_col,
            text="WPA Handshake Capture",
            variable=wpa_var,
            bg=bg, fg=fg
        )
        wpa_check.pack(anchor=tk.W, pady=2)
        
        # Right column - 3 checkboxes
        # Moved WEP attack to the right column for balance
        wep_check = tk.Checkbutton(
            right_col,
            text="WEP Attack",
            variable=wep_var,
            bg=bg, fg=fg
        )
        wep_check.pack(anchor=tk.W, pady=2)
        
        ip_detect_check = tk.Checkbutton(
            right_col,
            text="IP Address Detection",
            variable=ip_detect_var,
            bg=bg, fg=fg
        )
        ip_detect_check.pack(anchor=tk.W, pady=2)
        
        port_scan_check = tk.Checkbutton(
            right_col,
            text="Port Scanning",
            variable=port_scan_var,
            bg=bg, fg=fg
        )
        port_scan_check.pack(anchor=tk.W, pady=2)
        
        # Timeout
        timeout_frame = tk.Frame(options_frame, bg=bg)
        timeout_frame.pack(fill=tk.X, padx=10, pady=(0, 10))
        
        timeout_label = tk.Label(
            timeout_frame,
            text="Timeout per attack (seconds):",
            bg=bg, fg=fg
        )
        timeout_label.pack(side=tk.LEFT, padx=(0, 5))
        
        timeout_var = tk.IntVar(value=60)
        timeout_entry = ttk.Spinbox(
            timeout_frame,
            from_=10,
            to=300,
            textvariable=timeout_var,
            width=5
        )
        timeout_entry.pack(side=tk.LEFT)
        
        # Button frame
        button_frame = tk.Frame(dialog, bg=bg)
        button_frame.pack(fill=tk.X, padx=20, pady=20)
        
        # Warning
        warning_label = tk.Label(
            button_frame,
            text="‚ö†Ô∏è Only use against networks you own or have permission to test!",
            fg="#FF0000",
            bg=bg
        )
        warning_label.pack(side=tk.LEFT)
        
        # Start button
        start_btn = ttk.Button(
            button_frame,
            text="Start Assessment",
            command=lambda: self.run_sequential_tests(
                sorted_networks,
                {
                    "DEFAULT_CREDS": def_creds_var.get(),
                    "WPS": wps_var.get(),
                    "WPA": wpa_var.get(),
                    "WEP": wep_var.get(),
                    "IP_DETECT": ip_detect_var.get(),
                    "PORT_SCAN": port_scan_var.get()
                },
                timeout_var.get(),
                dialog
            )
        )
        start_btn.pack(side=tk.RIGHT, padx=5)
        
        # Cancel button
        cancel_btn = ttk.Button(
            button_frame,
            text="Cancel",
            command=dialog.destroy
        )
        cancel_btn.pack(side=tk.RIGHT, padx=5)
        
        # Make sure it opens maximized
        dialog.update_idletasks()
        dialog.state('zoomed')
        
    def run_sequential_tests(self, networks, attack_config, timeout_per_network, dialog):
        """Run sequential tests on multiple networks"""
        # Close the dialog
        dialog.destroy()
        
        # Switch to console tab
        self.notebook.select(0)
        
        # Disable scan button and enable stop button
        self.scan_btn.config(state=tk.DISABLED)
        self.stop_btn.config(state=tk.NORMAL)
        
        # Set attacking flag
        self.attacking = True
        
        # Start the sequential test in a background thread
        self.attack_thread = threading.Thread(
            target=self.run_sequential_tests_thread,
            args=(networks, attack_config, timeout_per_network)
        )
        self.attack_thread.daemon = True
        self.attack_thread.start()
        
    def run_sequential_tests_thread(self, networks, attack_config, timeout_per_network):
        """Run sequential tests in background thread"""
        try:
            # Convert attack config to enum types
            attack_types = {}
            for key, value in attack_config.items():
                if value:
                    attack_types[getattr(AttackType, key)] = True
            
            # Start the test
            self.log(f"Starting automated assessment of {len(networks)} networks...",
                    phase="SEQUENCE")
            
            # Store results for report
            results = []
            total_networks = len(networks)
            
            # Process each network with selected attacks
            for index, network in enumerate(networks):
                if not self.attacking:  # Allow stopping during the test
                    break
                    
                # Update progress
                progress = int((index / total_networks) * 100)
                self.update_progress(progress)
                
                # Log network being tested
                self.log(f"Testing network {index+1}/{total_networks}: {network.ssid or network.bssid}...", 
                       phase="SEQUENCE")
                
                # Set as current target for proper display
                self.current_target = network
                
                # Determine device type for appropriate attack selection
                device_type = network.type.lower() if hasattr(network, 'type') and network.type else "unknown"
                security = network.security_type.upper() if hasattr(network, 'security_type') else ""
                
                network_results = {"ssid": network.ssid, "bssid": network.bssid, "attacks": []}
                
                # WPA Attack - run on routers with WPA security if WPA attack is selected
                if attack_types.get(AttackType.WPA, False) and "WPA" in security:
                    self.log(f"Running WPA handshake capture on {network.ssid}...", phase="WPA")
                    success, message, result = self.controller.perform_attack(AttackType.WPA, network)
                    
                    if success:
                        # Start immediate password cracking here
                        self.log(f"WPA handshake captured! Starting password cracking...", success=True, phase="WPA")
                        crack_success, password = self.controller.crack_wpa_password(result.get('capture_file'))
                        if crack_success:
                            self.log(f"PASSWORD FOUND: {password}", success=True, phase="WPA")
                            network_results["attacks"].append({"type": "WPA", "success": True, "details": f"Password: {password}"})
                        else:
                            self.log(f"Password not found during quick cracking. Saved handshake for offline cracking.", phase="WPA")
                            network_results["attacks"].append({"type": "WPA", "success": False, "details": f"Handshake captured, no password found"})
                    else:
                        self.log(f"WPA attack failed: {message}", error=True, phase="WPA")
                        network_results["attacks"].append({"type": "WPA", "success": False, "details": message})
                
                # WPS Attack - run on WPS-enabled devices if WPS attack is selected
                if attack_types.get(AttackType.WPS, False) and hasattr(network, 'wps_status') and network.wps_status != "Disabled":
                    self.log(f"Running WPS PIN attack on {network.ssid}...", phase="WPS")
                    success, message, result = self.controller.perform_attack(AttackType.WPS, network)
                    
                    if success:
                        wps_pin = result.get('pin')
                        wps_password = result.get('password')
                        self.log(f"WPS attack successful! PIN: {wps_pin}, Password: {wps_password}", success=True, phase="WPS")
                        network_results["attacks"].append({"type": "WPS", "success": True, "details": f"PIN: {wps_pin}, Password: {wps_password}"})
                    else:
                        self.log(f"WPS attack failed: {message}", error=True, phase="WPS")
                        network_results["attacks"].append({"type": "WPS", "success": False, "details": message})
                
                # WEP Attack - run on WEP networks if WEP attack is selected
                if attack_types.get(AttackType.WEP, False) and "WEP" in security:
                    self.log(f"Running WEP attack on {network.ssid}...", phase="WEP")
                    success, message, result = self.controller.perform_attack(AttackType.WEP, network)
                    
                    if success:
                        wep_key = result.get('key')
                        self.log(f"WEP attack successful! Key: {wep_key}", success=True, phase="WEP")
                        network_results["attacks"].append({"type": "WEP", "success": True, "details": f"Key: {wep_key}"})
                    else:
                        self.log(f"WEP attack failed: {message}", error=True, phase="WEP")
                        network_results["attacks"].append({"type": "WEP", "success": False, "details": message})
                
                # Default Credentials - only check for IoT devices and cameras, never routers
                if attack_types.get(AttackType.DEFAULT_CREDS, False):
                    # Improved detection - check if this is a router or IoT device
                    # Keywords to identify router devices
                    router_keywords = ["router", "access point", "gateway", "modem", "network", "wireless", "wifi", "ap"]
                    # Keywords to identify IoT/cameras/smart devices
                    iot_keywords = ["camera", "cam", "iot", "smart", "device", "ip cam", "doorbell", "thermostat", 
                                    "speaker", "bulb", "light", "sensor", "monitor", "detection", "security"]
                    
                    # Check for router
                    is_router = False
                    for keyword in router_keywords:
                        if keyword in device_type:
                            is_router = True
                            break
                            
                    # Check if it's an IoT/camera device
                    is_iot = False
                    for keyword in iot_keywords:
                        if keyword in device_type:
                            is_iot = True
                            break
                    
                    # If no type is detected but there's a vendor, check if it's a known IoT vendor
                    if not is_iot and not is_router and hasattr(network, 'vendor') and network.vendor:
                        vendor = network.vendor.lower()
                        iot_vendors = ["hikvision", "dahua", "axis", "foscam", "wansview", "nest", "ring", 
                                      "wyze", "yi", "tp-link", "arlo", "amcrest", "tuya", "lorex"]
                        
                        # If it's a known IoT vendor, mark as IoT device
                        for iot_vendor in iot_vendors:
                            if iot_vendor in vendor:
                                is_iot = True
                                self.log(f"Detected IoT device based on vendor: {network.vendor}", phase="CREDS")
                                break
                    
                    # Skip the attack if it's a router or not identified as IoT
                    if is_router:
                        self.log(f"Skipping default credentials check on router {network.ssid}", warning=True, phase="CREDS")
                        network_results["attacks"].append({"type": "DEFAULT_CREDS", "success": False, "details": "Not applicable for routers"})
                    elif not is_iot:
                        self.log(f"Device type cannot be determined, classifying as general device", warning=True, phase="CREDS")
                        # For unidentified devices, still run the check but with low expectation
                        self.log(f"Checking default credentials for unidentified device {network.ssid}...", phase="CREDS")
                        success, message, result = self.controller.perform_attack(AttackType.DEFAULT_CREDS, network)
                        
                        if success and result.get('creds'):
                            creds = result.get('creds', [])
                            cred_info = ", ".join([f"{c.get('username')}:{c.get('password')}" for c in creds[:3]])
                            self.log(f"Default credentials found: {cred_info}", success=True, phase="CREDS")
                            network_results["attacks"].append({"type": "DEFAULT_CREDS", "success": True, "details": f"Found: {cred_info}"})
                        else:
                            self.log(f"No default credentials found for unidentified device", phase="CREDS")
                            network_results["attacks"].append({"type": "DEFAULT_CREDS", "success": False, "details": "No credentials found for unidentified device"})
                    else:
                        # This is an IoT device - run the default credentials check
                        self.log(f"Checking default credentials for IoT device {network.ssid}...", phase="CREDS")
                        success, message, result = self.controller.perform_attack(AttackType.DEFAULT_CREDS, network)
                        
                        if success and result.get('creds'):
                            creds = result.get('creds', [])
                            cred_info = ", ".join([f"{c.get('username')}:{c.get('password')}" for c in creds[:3]])
                            self.log(f"Default credentials found: {cred_info}", success=True, phase="CREDS")
                            network_results["attacks"].append({"type": "DEFAULT_CREDS", "success": True, "details": f"Found: {cred_info}"})
                        else:
                            self.log(f"No default credentials found for IoT device", phase="CREDS")
                            network_results["attacks"].append({"type": "DEFAULT_CREDS", "success": False, "details": "No default credentials found for IoT device"})
                
                # IP Address Detection - run before port scanning
                if attack_types.get(AttackType.IP_DETECT, False):
                    self.log(f"Detecting IP address for {network.ssid}...", phase="IP")
                    success, message, result = self.controller.perform_attack(AttackType.IP_DETECT, network)
                    
                    if success and result.get('ip'):
                        ip_address = result.get('ip')
                        self.log(f"IP address detected: {ip_address}", success=True, phase="IP")
                        network.gateway = ip_address  # Store for port scanning
                        network_results["attacks"].append({"type": "IP_DETECT", "success": True, "details": f"IP: {ip_address}"})
                    else:
                        self.log(f"IP address detection failed: {message}", error=True, phase="IP")
                        network_results["attacks"].append({"type": "IP_DETECT", "success": False, "details": message})
                
                # Port Scan - run if selected (uses IP address from previous step)
                if attack_types.get(AttackType.PORT_SCAN, False):
                    # Only attempt port scan if we have an IP address
                    if hasattr(network, 'gateway') and network.gateway:
                        self.log(f"Running port scan on {network.ssid} ({network.gateway})...", phase="SCAN")
                        success, message, result = self.controller.perform_attack(AttackType.PORT_SCAN, network)
                        
                        if success and result.get('open_ports'):
                            ports = result.get('open_ports', [])
                            port_info = ", ".join([f"{p}" for p in ports[:10]])
                            self.log(f"Open ports found: {port_info}", success=True, phase="SCAN")
                            network_results["attacks"].append({"type": "PORT_SCAN", "success": True, "details": f"Open ports: {port_info}"})
                        else:
                            self.log(f"No open ports found or scan failed: {message}", warning=True, phase="SCAN")
                            network_results["attacks"].append({"type": "PORT_SCAN", "success": False, "details": message})
                    else:
                        self.log(f"Cannot run port scan for {network.ssid}: No IP address available", warning=True, phase="SCAN")
                        network_results["attacks"].append({"type": "PORT_SCAN", "success": False, "details": "No IP address available"})
                
                # Add results for this network
                results.append(network_results)
                
                # Small delay between networks
                time.sleep(1)
            
            # Log completion
            self.log(f"Automated assessment complete. Tested {len(networks)} networks.",
                   success=True, phase="SEQUENCE")
            self.update_progress(100)
            
            # Ask to generate report
            if messagebox.askyesno("Assessment Complete", 
                                 "Would you like to generate a report of the assessment?"):
                self.generate_report(results)
                
        except Exception as e:
            self.log(f"Sequential test error: {str(e)}", error=True)
            
        finally:
            # Reset UI state
            self.attacking = False
            self.scan_btn.config(state=tk.NORMAL)
            self.stop_btn.config(state=tk.DISABLED)
            self.update_progress(100)
            
    # Helper functions to get real data for reports
    def get_networks_from_history(self):
        """Get real network scan results from scan history"""
        try:
            real_networks = []
            
            # Check for networks in scan history first
            if hasattr(self, 'networks') and self.networks:
                for network in self.networks:
                    if hasattr(network, 'ssid') and network.ssid:
                        real_networks.append(network)
            
            # If we still don't have networks, look for them in the interface table
            if not real_networks and hasattr(self, 'network_table') and self.network_table:
                # Get networks from the UI table
                for item_id in self.network_table.get_children():
                    network_data = {}
                    values = self.network_table.item(item_id)['values']
                    if len(values) >= 4:
                        network_data['ssid'] = values[0]
                        network_data['bssid'] = values[1]
                        network_data['channel'] = values[2]
                        network_data['security_type'] = values[3]
                        if len(values) > 4:
                            network_data['signal_strength'] = values[4]
                        if len(values) > 5:
                            network_data['clients'] = values[5]
                        real_networks.append(network_data)
            
            # If we still don't have networks, check the cached real data file
            if not real_networks:
                import os
                import json
                networks_file = os.path.join("data", "networks", "latest_scan.json")
                if os.path.exists(networks_file):
                    try:
                        with open(networks_file, 'r') as f:
                            cached_networks = json.load(f)
                            if cached_networks and isinstance(cached_networks, list):
                                for network in cached_networks:
                                    if isinstance(network, dict) and 'ssid' in network and 'bssid' in network:
                                        real_networks.append(network)
                    except Exception as e2:
                        print(f"Error loading networks from cache: {e2}")
            
            return real_networks
        except Exception as e:
            print(f"Error getting networks from history: {e}")
            return []
    
    def get_attack_results_from_history(self):
        """Get real attack results from attack history"""
        try:
            attack_data = {}
            
            # First check attack log for real attack results from the current session
            if hasattr(self, 'attack_log') and self.attack_log:
                log_text = self.attack_log.get('1.0', tk.END)
                if "WPA handshake captured" in log_text:
                    # Extract real network info from log
                    for line in log_text.split('\n'):
                        if "WPA handshake captured for" in line:
                            parts = line.split("for ")[1].split(" ")
                            if len(parts) >= 2:
                                bssid = parts[1].strip("()")
                                ssid = parts[0]
                                attack_data[bssid] = {
                                    "network": {"ssid": ssid, "bssid": bssid},
                                    "attacks": {"wpa_handshake": {"success": True, "timestamp": "Today"}}
                                }
                
                if "Password found" in log_text:
                    # Extract real password info from log
                    for line in log_text.split('\n'):
                        if "Password found for" in line:
                            parts = line.split("for ")[1].split(":")
                            if len(parts) >= 2:
                                network_info = parts[0].split(" ")
                                if len(network_info) >= 2:
                                    bssid = network_info[1].strip("()")
                                    ssid = network_info[0]
                                    password = parts[1].strip()
                                    if bssid not in attack_data:
                                        attack_data[bssid] = {
                                            "network": {"ssid": ssid, "bssid": bssid},
                                            "attacks": {}
                                        }
                                    attack_data[bssid]["attacks"]["password_cracking"] = {
                                        "success": True, 
                                        "password": password, 
                                        "timestamp": "Today"
                                    }
            
            # If no attack data in current session, load from real cached results
            if not attack_data:
                import os
                import json
                attacks_file = os.path.join("data", "attacks", "latest_results.json")
                if os.path.exists(attacks_file):
                    try:
                        with open(attacks_file, 'r') as f:
                            cached_attacks = json.load(f)
                            if cached_attacks and isinstance(cached_attacks, dict):
                                attack_data = cached_attacks
                    except Exception as e2:
                        print(f"Error loading attack results from cache: {e2}")
            
            return attack_data
        except Exception as e:
            print(f"Error getting attack results from history: {e}")
            return {}
    
    def get_postex_data_from_history(self):
        """Get real post-exploitation data from session history"""
        try:
            postex_data = {"hosts": [], "services": [], "vulnerabilities": []}
            
            # First check post-exploitation log/console for results from current session
            if hasattr(self, 'postex_console') and self.postex_console:
                log_text = self.postex_console.get('1.0', tk.END)
                
                # Extract host discoveries
                if "Host discovery complete" in log_text:
                    # Process host discovery results
                    host_section = False
                    for line in log_text.split('\n'):
                        if "Host discovery complete" in line:
                            host_section = False
                        
                        if host_section and line.strip():
                            parts = line.strip().split()
                            if len(parts) >= 2:
                                host_data = {"ip": parts[0]}
                                if len(parts) > 1:
                                    host_data["mac"] = parts[1]
                                if len(parts) > 2:
                                    host_data["hostname"] = parts[2]
                                if len(parts) > 3:
                                    host_data["vendor"] = " ".join(parts[3:])
                                postex_data["hosts"].append(host_data)
                        
                        if "Starting host discovery" in line:
                            host_section = True
                
                # Extract service discoveries
                if "Service detection complete" in log_text:
                    # Process service detection results
                    service_section = False
                    for line in log_text.split('\n'):
                        if "Service detection complete" in line:
                            service_section = False
                        
                        if service_section and line.strip():
                            parts = line.strip().split()
                            if len(parts) >= 3:
                                # Format: IP:PORT SERVICE VERSION
                                ip_port = parts[0].split(':')
                                if len(ip_port) == 2:
                                    service_data = {
                                        "host": ip_port[0],
                                        "port": ip_port[1],
                                        "service": parts[1],
                                    }
                                    if len(parts) > 2:
                                        service_data["version"] = " ".join(parts[2:])
                                        service_data["risk"] = "Medium"  # Default risk
                                    postex_data["services"].append(service_data)
                        
                        if "Starting service detection" in line:
                            service_section = True
                
                # Extract vulnerabilities
                if "Vulnerability scan complete" in log_text:
                    # Process vulnerability scan results
                    vuln_section = False
                    for line in log_text.split('\n'):
                        if "Vulnerability scan complete" in line:
                            vuln_section = False
                        
                        if vuln_section and line.strip() and "VULNERABILITY:" in line:
                            parts = line.split("VULNERABILITY:")[1].strip().split('|')
                            if len(parts) >= 3:
                                vuln_data = {
                                    "host": parts[0].strip(),
                                    "service": parts[1].strip(),
                                    "severity": "High" if "Critical" in line else "Medium",
                                    "description": parts[2].strip()
                                }
                                if len(parts) > 3:
                                    vuln_data["cve"] = parts[3].strip()
                                postex_data["vulnerabilities"].append(vuln_data)
                        
                        if "Starting vulnerability scan" in line:
                            vuln_section = True
            
            # If no post-exploitation data from current session, load cached real data
            if not postex_data['hosts'] and not postex_data['services'] and not postex_data['vulnerabilities']:
                import os
                import json
                postex_file = os.path.join("data", "post_exploitation", "latest_results.json")
                if os.path.exists(postex_file):
                    try:
                        with open(postex_file, 'r') as f:
                            cached_postex = json.load(f)
                            if cached_postex and isinstance(cached_postex, dict):
                                postex_data = cached_postex
                    except Exception as e2:
                        print(f"Error loading post-exploitation data from cache: {e2}")
            
            return postex_data
        except Exception as e:
            print(f"Error getting post-exploitation data from history: {e}")
            return {"hosts": [], "services": [], "vulnerabilities": []}
    
    def get_traffic_data_from_history(self):
        """Get real network traffic data from monitoring session"""
        try:
            traffic_data = {"packets": [], "sensitive_data": [], "alerts": []}
            
            # First check network monitor log for results from current session
            if hasattr(self, 'traffic_console') and self.traffic_console:
                log_text = self.traffic_console.get('1.0', tk.END)
                
                # Process packet captures
                packet_section = False
                for line in log_text.split('\n'):
                    if "Packet capture complete" in line:
                        packet_section = False
                    
                    if packet_section and line.strip():
                        parts = line.strip().split()
                        if len(parts) >= 3:
                            packet_data = {}
                            if "TCP" in line:
                                packet_data["protocol"] = "TCP"
                            elif "UDP" in line:
                                packet_data["protocol"] = "UDP"
                            elif "ICMP" in line:
                                packet_data["protocol"] = "ICMP"
                            elif "DNS" in line:
                                packet_data["protocol"] = "DNS"
                            else:
                                packet_data["protocol"] = "Other"
                            
                            # Extract source/destination if available
                            for i, part in enumerate(parts):
                                if ">" in part and i > 0:
                                    src_dst = part.split(">")
                                    if len(src_dst) == 2:
                                        packet_data["source"] = src_dst[0]
                                        packet_data["destination"] = src_dst[1]
                                        break
                            
                            traffic_data["packets"].append(packet_data)
                    
                    if "Starting packet capture" in line:
                        packet_section = True
                
                # Process sensitive data detections
                if "Sensitive data detected" in log_text:
                    # Example format: [TYPE] source > destination: details
                    for line in log_text.split('\n'):
                        if "[PASSWORD]" in line or "[CREDENTIAL]" in line or "[API_KEY]" in line:
                            data_type = line[line.find("[")+1:line.find("]")]
                            protocol = "HTTP"
                            if "HTTP" in line:
                                protocol = "HTTP"
                            elif "HTTPS" in line:
                                protocol = "HTTPS"
                            elif "FTP" in line:
                                protocol = "FTP"
                            
                            # Extract source/destination
                            if ">" in line:
                                src_dst = line.split(">")
                                source = src_dst[0].strip().split()[-1]
                                
                                details = "Sensitive data detected"
                                if ":" in src_dst[1]:
                                    dest_details = src_dst[1].split(":", 1)
                                    destination = dest_details[0].strip()
                                    details = dest_details[1].strip()
                                else:
                                    destination = src_dst[1].strip().split()[0]
                                
                                sensitive_data = {
                                    "type": data_type,
                                    "source": source,
                                    "destination": destination,
                                    "protocol": protocol,
                                    "details": details
                                }
                                traffic_data["sensitive_data"].append(sensitive_data)
                
                # Process alerts
                if "ALERT:" in log_text:
                    for line in log_text.split('\n'):
                        if "ALERT:" in line:
                            alert_parts = line.split("ALERT:")[1].strip().split('-')
                            if len(alert_parts) >= 2:
                                severity = "Medium"
                                if "Critical" in line or "HIGH" in line:
                                    severity = "High"
                                elif "LOW" in line:
                                    severity = "Low"
                                
                                description = alert_parts[0].strip()
                                source = "Unknown"
                                destination = "Unknown"
                                
                                # Try to extract source/destination from details
                                details = alert_parts[1].strip()
                                if ">" in details:
                                    src_dst = details.split(">")
                                    source = src_dst[0].strip()
                                    destination = src_dst[1].strip()
                                
                                alert_data = {
                                    "severity": severity,
                                    "source": source,
                                    "destination": destination,
                                    "description": description,
                                    "timestamp": datetime.now().strftime("%H:%M:%S")
                                }
                                traffic_data["alerts"].append(alert_data)
            
            # If no traffic data from current session, load from cached real data
            if not traffic_data['packets'] and not traffic_data['sensitive_data'] and not traffic_data['alerts']:
                import os
                import json
                traffic_file = os.path.join("data", "network_traffic", "latest_results.json")
                if os.path.exists(traffic_file):
                    try:
                        with open(traffic_file, 'r') as f:
                            cached_traffic = json.load(f)
                            if cached_traffic and isinstance(cached_traffic, dict):
                                traffic_data = cached_traffic
                    except Exception as e2:
                        print(f"Error loading network traffic data from cache: {e2}")
            
            return traffic_data
        except Exception as e:
            print(f"Error getting traffic data from history: {e}")
            return {"packets": [], "sensitive_data": [], "alerts": []}
        
    def generate_report(self, results=None):
        """Generate a security assessment report"""
        if not results and not self.controller.results and not self.scan_results:
            messagebox.showerror("Error", "No scan results or attack results to include in report")
            return
            
        # Ask for save location
        filename = filedialog.asksaveasfilename(
            title="Save Security Report",
            defaultextension=".pdf",
            filetypes=[("PDF Files", "*.pdf"), ("All Files", "*.*")]
        )
        
        if not filename:
            return
            
        try:
            # Generate report
            self.log("Generating security report...", phase="REPORT")
            
            # Ask if user wants simple report or advanced visual report
            if messagebox.askyesno("Report Type", 
                                "Would you like to generate an advanced visual report with charts and graphs?\n\n"
                                "Choose 'Yes' for advanced visual report with charts and graphs.\n"
                                "Choose 'No' for a simple text report."):
                # Use advanced reports
                try:
                    from src.advanced_reports import ReportGenerator as AdvancedReportGenerator
                    
                    # Create advanced report generator
                    adv_report_gen = AdvancedReportGenerator(controller=self.controller)
                    
                    # Make sure data is loaded
                    adv_report_gen.load_data_from_controller()
                    
                    # Set default company info
                    adv_report_gen.set_company_info("Client Organization", "Security Analyst")
                    
                    # Generate PDF report
                    adv_filename = adv_report_gen.generate_pdf_report(output_filename=filename)
                    
                    if adv_filename:
                        filename = adv_filename  # Update filename for success message
                        self.log(f"Advanced report generated successfully: {filename}", success=True)
                    else:
                        raise Exception("Failed to generate advanced report")
                        
                except Exception as e:
                    self.log(f"Advanced report generation failed: {str(e)}, falling back to simple report", warning=True)
                    
                    # Try the simple report as fallback
                    try:
                        from src.simple_report import SimpleReportGenerator
                        simple_report_gen = SimpleReportGenerator(controller=self.controller)
                        
                        # Prepare data for report
                        report_data = {
                            "networks": self.scan_results,
                            "attack_results": results if results else self.controller.results
                        }
                        
                        # Generate the report
                        success, msg = simple_report_gen.generate_report(filename, report_data)
                        
                        if not success:
                            raise Exception(msg)
                            
                    except Exception as e2:
                        self.log(f"Simple report generation also failed: {str(e2)}", error=True)
            else:
                # Use simple report (original functionality)
                try:
                    from src.simple_report import SimpleReportGenerator
                    simple_report_gen = SimpleReportGenerator(controller=self.controller)
                    
                    # Prepare data for report with ACTUAL real-time results - 100% REAL DATA ONLY
                    report_data = {
                        "networks": self.scan_results if self.scan_results else self.get_networks_from_history(),
                        "attack_results": results if results else (self.controller.results if hasattr(self.controller, 'results') else self.get_attack_results_from_history()),
                        "post_exploitation_data": self.controller.post_exploitation_data if hasattr(self.controller, 'post_exploitation_data') else self.get_postex_data_from_history(),
                        "network_traffic": self.controller.network_monitor_data if hasattr(self.controller, 'network_monitor_data') else self.get_traffic_data_from_history()
                    }
                    
                    # Generate the report
                    success, msg = simple_report_gen.generate_report(filename, report_data)
                    
                    if not success:
                        raise Exception(msg)
                        
                    self.log(f"Simple report generated successfully: {filename}", success=True)
                        
                except Exception as e:
                    # Fall back to original report generator
                    self.log(f"Simple report generation failed: {str(e)}, trying original report generator", warning=True)
                    
                    try:
                        # Try using the original report generator
                        from src.report_generator import ReportGenerator as OriginalReportGenerator
                        original_report_gen = OriginalReportGenerator(controller=self.controller)
                        
                        # Generate the report with original generator
                        original_report_gen.generate_report(filename, self.scan_results, 
                                                        results if results else self.controller.results)
                            
                        self.log(f"Original report generated successfully: {filename}", success=True)
                            
                    except Exception as e2:
                        self.log(f"Original report generation failed: {str(e2)}", error=True)
                        messagebox.showerror("Report Generation Failed", 
                                            f"Failed to generate report. Please check logs for details.")
                
            self.log(f"Report saved to {filename}", success=True, phase="REPORT")
            
            # Ask to open the report
            if messagebox.askyesno("Report Generated", 
                                "Report generated successfully. Open it now?"):
                webbrowser.open(filename)
                
        except Exception as e:
            self.log(f"Error generating report: {str(e)}", error=True)
            messagebox.showerror("Report Error", f"Error generating report: {str(e)}")
            
    def check_prerequisites(self):
        """Check for required tools and permissions"""
        if self.is_dev_mode:
            # Skip checks in development mode
            self.log("DEVELOPMENT MODE: Skipping prerequisite checks", warning=True)
            return
            
        # Check for tools
        tools = [
            "aircrack-ng", "airodump-ng", "aireplay-ng", "airmon-ng", 
            "reaver", "wash", "hcxdumptool", "hcxpcapngtool"
        ]
        
        available, missing = SecurityUtils.check_tool_availability(tools, self.log)
        
        if not available:
            self.log(f"Missing required tools: {', '.join(missing)}", error=True)
            messagebox.showwarning("Missing Tools", 
                                 f"The following required tools are missing:\n\n{', '.join(missing)}\n\nSome functionality may not work correctly.")
                                 
        # Check for root privileges
        if not SecurityUtils.check_permissions():
            self.log("Running without root privileges. Some functionality will be limited.", error=True)
            messagebox.showwarning("Permission Error", 
                                "This tool requires root privileges to access wireless interfaces.\n\nPlease restart with sudo.")
                                
    def load_config(self):
        """Load configuration from JSON file"""
        # Load configuration
        config = load_config()
        
        if config:
            # Apply saved settings
            if "dark_mode" in config:
                self.dark_mode = config["dark_mode"]
            
            # Load font size preference
            if "font_size" in config:
                self.font_size = config["font_size"]
                if hasattr(self, 'theme_manager'):
                    self.theme_manager.font_size = self.font_size
                    
                # Update font size selector if it exists
                if hasattr(self, 'font_size_var'):
                    # Convert from "small" to "Small" format for display
                    display_value = self.font_size.replace('_', ' ').title()
                    self.font_size_var.set(display_value)
                
            if "attack_params" in config:
                # Update attack parameters
                params = self.controller.attack_params
                for key, value in config["attack_params"].items():
                    if hasattr(params, key):
                        setattr(params, key, value)
                        
                # Update modules with new parameters
                for module in self.controller.attack_modules.values():
                    module.attack_params = params
                    
            # Load scan time if available
            if "scan_time" in config:
                self.scan_time_var.set(config["scan_time"])
                
    def save_config(self):
        """Save configuration to JSON file"""
        config = {
            "dark_mode": self.dark_mode,
            "font_size": self.font_size,  # Save font size preference
            "scan_time": self.scan_time_var.get(),
            "attack_params": self.controller.attack_params.to_dict()
        }
        
        # Save configuration
        save_config(config)
